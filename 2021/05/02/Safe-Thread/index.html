<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>关于线程安全 | Coding</title>

  
  <meta name="author" content="Rick Li">
  

  
  <meta name="description" content="线程安全可变字典的简单实现。 在大多数情况下，您需要使用NSCache，但是在需要手动控制内存不足的情况下从缓存中清除的内容时，它很有用。警告：我仅将其用于设置/获取密钥。 枚举在这里不是线程安全的，并且仍然会引发异常…
123456#import &amp;lt;Foundation/Foundation">
  

  
  
  <meta name="keywords" content="iOS">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="关于线程安全"/>

  <meta property="og:site_name" content="Coding"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Coding" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Coding</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>关于线程安全</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/Safe-Thread/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T11:00:34.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>线程安全可变字典的简单实现。 在大多数情况下，您需要使用NSCache，但是在需要手动控制内存不足的情况下从缓存中清除的内容时，它很有用。<strong>警告：</strong>我仅将其用于设置/获取密钥。 枚举在这里不是线程安全的，并且仍然会引发异常…</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dictionary-Subclasss whose primitive operations are thread safe.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JPThreadSafeMutableDictionary</span> : <span class="title">NSMutableDictionary</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;JPThreadSafeMutableDictionary.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKED(...) OSSpinLockLock(&amp;_lock); \</span></span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">OSSpinLockUnlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPThreadSafeMutableDictionary</span> </span>&#123;</span><br><span class="line">    OSSpinLock _lock;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *_dictionary; <span class="comment">// Class Cluster!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSObject</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCapacity:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithObjects:(<span class="built_in">NSArray</span> *)objects forKeys:(<span class="built_in">NSArray</span> *)keys &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">self</span> initWithCapacity:objects.count])) &#123;</span><br><span class="line">        [objects enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            _dictionary[keys[idx]] = obj;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _dictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:capacity];</span><br><span class="line">        _lock = OS_SPINLOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSMutableDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey &#123;</span><br><span class="line">    LOCKED(_dictionary[aKey] = anObject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addEntriesFromDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary &#123;</span><br><span class="line">    LOCKED([_dictionary addEntriesFromDictionary:otherDictionary]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary &#123;</span><br><span class="line">    LOCKED([_dictionary setDictionary:otherDictionary]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)aKey &#123;</span><br><span class="line">    LOCKED([_dictionary removeObjectForKey:aKey])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    LOCKED([_dictionary removeAllObjects]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSUInteger</span> count = _dictionary.count)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)allKeys &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSArray</span> *allKeys = _dictionary.allKeys)</span><br><span class="line">    <span class="keyword">return</span> allKeys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)allValues &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSArray</span> *allValues = _dictionary.allValues)</span><br><span class="line">    <span class="keyword">return</span> allValues;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)aKey &#123;</span><br><span class="line">    LOCKED(<span class="keyword">id</span> obj = _dictionary[aKey])</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)keyEnumerator &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSEnumerator</span> *keyEnumerator = [_dictionary keyEnumerator])</span><br><span class="line">    <span class="keyword">return</span> keyEnumerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mutableCopyWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    LOCKED(<span class="keyword">id</span> copiedDictionary = [[<span class="keyword">self</span>.class allocWithZone:zone] initWithDictionary:_dictionary])</span><br><span class="line">    <span class="keyword">return</span> copiedDictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">                                  objects:(<span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> [])stackbuf</span><br><span class="line">                                    count:(<span class="built_in">NSUInteger</span>)len &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSUInteger</span> count = [[_dictionary <span class="keyword">copy</span>] countByEnumeratingWithState:state objects:stackbuf count:len]);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performLockedWithDictionary:(<span class="keyword">void</span> (^)(<span class="built_in">NSDictionary</span> *dictionary))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (block) LOCKED(block(_dictionary));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:JPThreadSafeMutableDictionary.class]) &#123;</span><br><span class="line">        JPThreadSafeMutableDictionary *other = object;</span><br><span class="line">        __block <span class="built_in">BOOL</span> isEqual = <span class="literal">NO</span>;</span><br><span class="line">        [other performLockedWithDictionary:^(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">            [<span class="keyword">self</span> performLockedWithDictionary:^(<span class="built_in">NSDictionary</span> *otherDictionary) &#123;</span><br><span class="line">                isEqual = [dictionary isEqual:otherDictionary];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> isEqual;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>LOCKED扩展为三个语句，而if仅保护第一个语句。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKED(...) do &#123; \</span></span><br><span class="line">OSSpinLockLock(&amp;_lock); \</span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">OSSpinLockUnlock(&amp;_lock); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">NO</span>)</span><br></pre></td></tr></table></figure>
<p>找到一个解决方案，给定countByEnumeratingWithState：在枚举开始之前被调用一次，在枚举结束之后被调用一次（上帝赐予。我们有“适当的时间”指示器）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">                                  objects:(<span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> [])stackbuf</span><br><span class="line">                                    count:(<span class="built_in">NSUInteger</span>)len &#123;</span><br><span class="line">    OSSpinLockLock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *enumerationDict = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;stackbuf);</span><br><span class="line">    <span class="keyword">if</span> (!enumerationDict) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;stackbuf, (enumerationDict = _dictionary.copy), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [enumerationDict countByEnumeratingWithState:state objects:stackbuf count:len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;stackbuf, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSpinLockUnlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果实现isEqual，则还必须实现-(int)hash方法（并且可能使用LOCK()宏返回[super hash]值）。</p>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>NSOperation是一个类，允许您以结构化方式对异步操作进行建模。 它为应用程序的高级部分提供了一种启动异步操作的方式，而不必担心它们如何执行的细节。  NSOperation可以在线程上运行，也可以通过运行循环回调或其他更特殊的方式异步运行。 重要的是您的应用程序的高级代码无关紧要。 它只是开始操作，并在操作完成时得到通知。</p>
<blockquote>
<p>重要提示：NSOperation通常用于在线程上运行CPU密集型代码，但不仅仅是线程。  NSOperation可用于对任何异步操作进行建模。 例如，示例代码“ LinkedImageFetcher”显示了如何使用NSOperation进行网络操作。</p>
</blockquote>
<p>NSOperation鼓励使用一种称为线程限制的编程模型。 在此模型中，线程使用的资源由​​该线程拥有，而不在线程之间共享。 这是一种编写线程代码的好方法，而不会涉及上一节中讨论的各种问题。 使用NSOperation的一种好方法是：</p>
<ul>
<li>使用完成工作所需的数据的不变副本来初始化操作。</li>
<li>执行操作； 在执行过程中，它仅对初始化时使用的数据以及它自己创建的数据进行操作，并且不与其他线程共享。</li>
<li>操作完成后，它将结果提供给应用程序的其余部分，此时，操作本身不再触及这些结果。</li>
</ul>
<p>使用单独的NSOperation对象解决了通用线程代码的许多问题：</p>
<ul>
<li>您可以将与操作相关的辅助数据存储为NSOperation对象的属性，</li>
<li>您可以使用这些属性，甚至NSOperation对象本身，作为标记来确定操作结果是否过时</li>
<li>NSOperation对象是您用来处理的句柄 可以取消该操作</li>
<li>您可以保证所有线程化代码都在该操作中运行，从而避免重新分配问题</li>
</ul>
<p>NSOperation还具有许多其他有用的功能：</p>
<ul>
<li>每个操作都由一个操作队列（NSOperationQueue）执行。 </li>
<li>每个队列都有一个并行执行的最大操作数（maxConcurrentOperationCount），通常称为队列宽度。 该宽度默认为适合您正在运行的设备的值，但是您可以将其设置为适合手头任务的值。 例如，可以通过将队列宽度设置为1来保证操作被序列化（一次执行一次）。或者，如果您的操作进入网络，则可以使用队列宽度来限制并发网络操作的数量。</li>
<li>您可以创建操作队列以对问题空间进行建模。 例如，文件复制程序可以在每个磁盘上使用一个操作队列，以避免损坏磁盘头。</li>
<li>您可以使操作依赖于其他操作，从而建立操作执行和操作扇入的链。<br>重要的是要意识到NSOperation和NSOperationQueue不会做您自己做不到的任何事情。 如果确实需要，可以使用自己的代码复制所有此结构。 但是，如果您没有用于管理异步代码的现有结构，并且不希望重新实现轮子，那么NSOperation非常适合您。</li>
</ul>
<p>使用NSOperation实现异步重新计算的第一步是创建一个NSOperation的子类来进行计算。 您应该特别注意操作的接口，如其头文件中所述。 最重要的是，该接口中的所有内容都应具有定义明确的线程安全性策略。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdderOperation</span> : <span class="title">NSOperation</span>  </span></span><br><span class="line">- (<span class="keyword">id</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;  <span class="comment">// only meaningful after the operation is finished  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readonly</span> ) <span class="built_in">NSString</span> * formattedTotal;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>该操作的初始化方法（在此示例中为-initWithNumbers :）应将运行该操作必不可少的所有信息作为参数。 在这种情况下，只需要添加数字列表即可。<br>此最小接口中的唯一其他项是客户端可用来获取操作结果的属性。 在这种情况下，formattedTotal属性是要在列表视图的总值中显示的字符串。</p>
<p>一个操作从NSOperation继承了各种重要的属性。 最关键的是isFinished属性。 客户端可以观察该属性（从键值观察（KVO）的角度），以确定何时完成该操作。 或者，如果您不是KVO的忠实拥护者，则可以使用其他机制进行操作，以表示已完成。 例如，您的操作可能会在完成后发布通知（使用NSNotificationCenter），或者它可能定义委托协议。</p>
<blockquote>
<p>警告：不管您的操作如何发出完成信号，您的客户端都必须知道发出该信号的线程。 此问题将在下面更详细地讨论。</p>
</blockquote>
<p>还有另一件事要注意：formattedTotal属性是原子的。 这是因为很可能同时从多个线程访问此属性，并且该属性必须是原子的，以确保安全。 通常，操作的所有公共属性都应该是原子的。</p>
<p>给定头文件，该操作必须包括以下内容的实现：</p>
<ul>
<li>initWithNumbers：方法-这有些微妙，下面将详细讨论。</li>
<li>formattedTotal属性-可以合成此属性。</li>
<li>dealloc方法—这里没有什么大的惊喜； 唯一的问题是该方法可以由任何线程执行。</li>
<li>main方法—这是您的操作进行计算的地方，下面将对其进行详细讨论<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers</span><br><span class="line">&#123;</span><br><span class="line">    assert(numbers != <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>-&gt;_numbers = [numbers <span class="keyword">copy</span>];</span><br><span class="line">        assert(<span class="keyword">self</span>-&gt;_numbers != <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里有两点需要注意：</li>
<li>该方法创建传入numbers数组的不可变副本。 这样可以防止前面讨论的问题，在该问题上，主线程可能会使数组发生变化，而运行该操作的辅助线程正在处理该数组。</li>
<li>由您决定是否使初始化方法线程安全。 因为您控制操作的分配，所以可以保证将在主线程（或其他特定的辅助线程）上调用该操作。 但是，如果使初始化方法线程安全相对容易，则应这样做。</li>
</ul>
<p>该操作的-main方法进行实际计算。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span>      numberCount;</span><br><span class="line">    <span class="built_in">NSUInteger</span>      numberIndex;</span><br><span class="line">    <span class="built_in">NSInteger</span>       total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is called by a thread that&#x27;s set up for us by the NSOperationQueue.</span></span><br><span class="line"></span><br><span class="line">    assert( ! [<span class="built_in">NSThread</span> isMainThread] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the heavy lifting (-:</span></span><br><span class="line"></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    numberCount = [<span class="keyword">self</span>.numbers count];</span><br><span class="line">    <span class="keyword">for</span> (numberIndex = <span class="number">0</span>; numberIndex &lt; numberCount; numberIndex++) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *  numberObj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for cancellation.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sleep for a second. This makes it easiest to test cancellation </span></span><br><span class="line">        <span class="comment">// and so on.</span></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the mathematics.</span></span><br><span class="line"></span><br><span class="line">        numberObj = [<span class="keyword">self</span>.numbers objectAtIndex:numberIndex];</span><br><span class="line">        assert([numberObj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]);</span><br><span class="line"></span><br><span class="line">        total += [numberObj integerValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set our output properties base on the value we calculated. Our client </span></span><br><span class="line">    <span class="comment">// shouldn&#x27;t look at these until -isFinished goes to YES (which happens when </span></span><br><span class="line">    <span class="comment">// we return from this method).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.formattedTotal = [<span class="keyword">self</span>.formatter stringFromNumber:[<span class="built_in">NSNumber</span> numberWithInteger:total]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键点包括：</p>
<ul>
<li>此方法应在辅助线程上运行。 它涉及的所有内容都必须具有某种线程安全性策略。 在此示例中：Numbers属性是线程安全的，因为只能通过-initWithNumbers：方法对其进行更改，该方法在运行此代码之前必须已完成。<br>numberCount，numberIndex，total和numberObj变量是安全的，因为它们是局部变量，因此不会在线程之间共享。<br>formattedTotal属性是安全的，因为在操作完成之前，客户端不应该查看它。 即使客户端忽略此要求，由于该属性是原子的，他们的访问也将是安全的：客户端将获得原始值（即nil）或正确值，而不会得到任何奇怪的杂烩。<br>该操作通过在其主计算循环中调用isCancelled来测试是否取消。<blockquote>
<p>重要提示：虽然并非严格要求标准操作检查取消，但强烈建议您执行此操作。 如果某个操作没有定期检查取消，则会浪费不再需要的资源计算结果。</p>
</blockquote>
</li>
</ul>
<p>在并发操作中支持取消操作比较棘手。 如果要创建并发操作，请参阅“并发操作”以获取有关如何正确执行此操作的信息。</p>
<p>一旦执行了可以执行任务的操作，就必须在应用程序中使用它。 第一步是创建一个NSOperationQueue，以在其上运行操​​作。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ListAdderViewController</span> () [...]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readonly</span> ) <span class="built_in">NSOperationQueue</span> * queue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readwrite</span>) AdderOperation *   inProgressAdder;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ListAdderViewController</span></span></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:<span class="built_in">UITableViewStyleGrouped</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [...] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>-&gt;_queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">        assert(<span class="keyword">self</span>-&gt;_queue != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">        [...] </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：如果可以重新分配视图控制器，则将操作队列托管在视图控制器中是很棘手的。 因为ListAdderViewController是根视图控制器，因此无法被释放。 如果您的视图控制器可能被释放，则必须采取措施避免其-dealloc方法在辅助线程上运行。 有关详细信息，请参见“分配问题”。</p>
</blockquote>
<p>一旦有了操作队列，就可以通过简单地将操作添加到队列中来开始操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recalculateTotalUsingOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re already calculating, cancel that operation.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.inProgressAdder != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.inProgressAdder cancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start up a replacement operation.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.inProgressAdder = [[[AdderOperation alloc] initWithNumbers:<span class="keyword">self</span>.numbers] autorelease];</span><br><span class="line">    assert(<span class="keyword">self</span>.inProgressAdder != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.inProgressAdder addObserver:<span class="keyword">self</span> </span><br><span class="line">        forKeyPath:<span class="string">@&quot;isFinished&quot;</span> </span><br><span class="line">        options:<span class="number">0</span> </span><br><span class="line">        context:&amp;<span class="keyword">self</span>-&gt;_formattedTotal</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.queue addOperation:<span class="keyword">self</span>.inProgressAdder];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The user interface is adjusted by a KVO observer on recalculating.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.recalculating = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两点需要注意：代码跟踪inProgressAdder属性中最近排队的操作。 当开始新操作时，它将用刚刚开始的操作替换该值。 这有两个好处：开始操作时，可以取消上一个操作。 这意味着新操作不仅会持续执行，还会消耗宝贵的CPU周期，电池寿命和内存。<br>操作完成后，可以确定操作结果是否仍然有意义。 在下面的更多内容。<br>在对操作进行排队之前，它将添加对isFinished属性的观察。 这样就可以确定操作何时完成。<br>最后，当操作完成时，您必须检查并提交结果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">    ofObject:(<span class="keyword">id</span>)object </span><br><span class="line">    change:(<span class="built_in">NSDictionary</span> *)change </span><br><span class="line">    context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == &amp;<span class="keyword">self</span>-&gt;_formattedTotal) &#123;</span><br><span class="line">        AdderOperation *    op;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the operation has finished, call -adderOperationDone: on the main thread to deal </span></span><br><span class="line">        <span class="comment">// with the results.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// can be running on any thread</span></span><br><span class="line">        assert([keyPath isEqual:<span class="string">@&quot;isFinished&quot;</span>]);</span><br><span class="line">        op = (AdderOperation *) object;</span><br><span class="line">        assert([op isKindOfClass:[AdderOperation <span class="keyword">class</span>]]);</span><br><span class="line">        assert([op isFinished]);</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(adderOperationDone:)</span><br><span class="line">            withObject:op </span><br><span class="line">            waitUntilDone:<span class="literal">NO</span></span><br><span class="line">        ];</span><br><span class="line">    &#125; [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)adderOperationDone:(AdderOperation *)op</span><br><span class="line">&#123;</span><br><span class="line">    assert([<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line"></span><br><span class="line">    assert(<span class="keyword">self</span>.recalculating);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always remove our observer, regardless of whether we care about </span></span><br><span class="line">    <span class="comment">// the results of this operation.</span></span><br><span class="line"></span><br><span class="line">    [op removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see whether these are the results we&#x27;re looking for. </span></span><br><span class="line">    <span class="comment">// If not, we just discard the results; later on we&#x27;ll be notified </span></span><br><span class="line">    <span class="comment">// of the latest add operation completing.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="keyword">self</span>.inProgressAdder) &#123;</span><br><span class="line">        assert( ! [op isCancelled] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the value to our model.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.formattedTotal = op.formattedTotal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear out our record of the operation. The user interface is adjusted </span></span><br><span class="line">        <span class="comment">// by a KVO observer on recalculating.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.inProgressAdder = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.recalculating = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此过程分为两部分。 首先，当操作的isFinished属性更改时，KVO调用-observeValueForKeyPath：ofObject：change：context：方法。 此方法与更改isFinished属性的代码在同一线程上运行，在这种情况下，这意味着它在辅助线程上运行。 它无法从辅助线程操纵用户界面，因此它通过使用-performSelectorOnMainThread：withObject：waitUntilDone：调用-adderOperationDone：方法来将工作推迟到主线程。</p>
<p>-adderOperationDone：方法执行三件事：</p>
<ul>
<li>删除对isFinished属性的观察。 </li>
<li>它通过将已完成的操作（op）与最近启动的操作（inProgressAdder）进行比较，以查看该操作的结果是否仍然有意义。 如果这些不匹配，则操作的结果无关紧要，并被丢弃。</li>
<li>如果操作的结果仍然有意义，则将它们提交给用户界面。</li>
</ul>
<p>整个过程的一个不明显的方面是inProgressAdder属性仅由主线程访问。 这意味着它不必一定是原子的，但更重要的是，它不需要任何并发控制。 如果没有这种隐式序列化，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="keyword">self</span>.inProgressAdder) &#123;     [... <span class="keyword">do</span> something with inProgressAdder ...]     <span class="keyword">self</span>.inProgressAdder = <span class="literal">nil</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>这总结了使用NSOperation异步运行长时间运行的计算的基本过程。 下一节将超越前面显示的最小实现，并涵盖一些更现实的情况。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdderOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line">&#123;</span><br><span class="line">    [... instance variables elided ...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up by the init method that can&#x27;t be changed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readonly</span> ) <span class="built_in">NSArray</span> *         numbers;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readonly</span> ) <span class="built_in">NSUInteger</span>        sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// must be configured before the operation is started</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSTimeInterval</span>    interNumberDelay;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only meaningful after the operation is finished</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readonly</span> ) <span class="built_in">NSInteger</span>         total;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readonly</span> ) <span class="built_in">NSString</span> *        formattedTotal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>而且，此接口通过在类扩展中声明的一堆内部属性进行了扩展。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdderOperation</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// only accessed by the operation thread</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">retain</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSNumberFormatter</span> *   formatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read/write versions of public properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span>             total;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *            formattedTotal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在这些接口中声明的每个属性都有一个定义明确的线程安全性策略。 这些策略包括：</p>
<ul>
<li>不变性-一些属性是在初始化时设置的，此后不修改。 数字数组就是一个很好的例子。</li>
<li>仅配置时间-可以在创建操作的点与开始操作的点之间安全地设置某些属性，例如interNumberDelay。 在那之后，修改此类属性既不安全，也无效。</li>
<li>线程限制-某些属性是线程安全的，因为只有运行该操作的线程才能访问这些属性。 格式化程序属性是此技术的一个示例。</li>
<li>串行线程限制-某些属性（例如total和formattedTotal）最初仅由操作使用，然后在操作完成时可用于其他代码。</li>
</ul>
<p>重要说明：在实施线程代码时，对于您从线程代码接触的每条数据制定线程安全策略至关重要。  NSOperation使开发此类策略变得更加容易。</p>
<h3 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h3><p>重要的是要认识到AdderOperation格式化程序属性是线程限制的一个人为的示例。 </p>
<p>在实际的应用程序中，线程限制是一种更为强大的技术。 具有异步解析XML的操作。 在此操作中，有一个NSXMLParser对象，在该对象中有一个libxml2 XML解析器对象。 可以从任意线程调用这些对象，但是一次只能从一个线程调用它们。 线程限制使从线程代码中安全地使用此类对象成为可能，而NSOperation是实现线程限制的好方法。</p>
<h2 id="NSOperations提示和技巧"><a href="#NSOperations提示和技巧" class="headerlink" title="NSOperations提示和技巧"></a>NSOperations提示和技巧</h2><p>本节包含一些使用NSOperation的常规提示和技巧。</p>
<h3 id="NSOperation和GCD"><a href="#NSOperation和GCD" class="headerlink" title="NSOperation和GCD"></a>NSOperation和GCD</h3><p>在iOS 4中引入的Grand Central Dispatch（GCD）与NSOperation的关系还不是很明显。 简短的答案是，这两种技术可以很好地互补。  GCD是一种低级API，可让您灵活地以各种不同的方式来构造代码。 相反，NSOperation为您提供了可用于异步代码的默认结构。 如果您正在寻找现有的，定义明确的，非常适合Cocoa应用程序的结构，请使用NSOperation。 如果您要创建自己的结构以完全匹配您的问题空间，请使用GCD。</p>
<h3 id="解除分配问题"><a href="#解除分配问题" class="headerlink" title="解除分配问题"></a>解除分配问题</h3><p>使用UIKit对象中的辅助线程（例如视图控制器）的最大问题之一是确保安全地释放对象。 本节说明了此问题的产生方式以及您可以采取的措施。<br>启动辅助线程时，该线程通常保留目标对象。 这种情况在很多情况下都会发生，包括：</p>
<ul>
<li>当您使用以下任何一种方法启动辅助线程时：<ul>
<li>-performSelectorInBackground：withObject：</li>
<li>-performSelector：onThread：withObject：waitUntilDone：</li>
<li>-performSelector：onThread：withObject：waitUntilDone：modes：</li>
</ul>
</li>
<li>当您使用NSThread启动辅助线程时 当您异步运行一个块并且该块引用了self或一个实例变量时</li>
<li> 当异步运行一个块并且该块引用了self或实例变量时，带有NSThread的辅助线程</li>
</ul>
<p>当辅助线程保留目标对象时，您必须确保在主线程释放其对该对象的最后一个引用之前，该线程释放该引用。 如果不这样做，则辅助线程将释放对对象的最后一个引用，这意味着对象的-dealloc方法在该辅助线程上运行。 如果对象的-dealloc方法在二级线程上执行不安全的操作，这是有问题的，这对于UIKit对象（如视图控制器）是常见的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)buttonAction:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused(sender)</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(recalculate) withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recalculate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ( ! <span class="keyword">self</span>.cancelled ) &#123;</span><br><span class="line">        [... calculate ...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// race starts here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-viewWillDisappear：取消方法集以停止辅助线程执行其计算。 这开始在正在忙于拆除视图控制器的主线程与注意到已设置并实际上已退出的canceled属性的辅助线程之间进行竞争。 在大多数情况下，辅助线程将赢得比赛，首先释放其引用，一切都会正常。 但是，如果主线程赢得比赛，并在辅助线程之前释放其引用，则辅助线程的释放将是最后一个释放，并且视图控制器的-dealloc方法将在辅助线程上运行。<br>您可能会想通过轮询辅助线程的isFinished属性来解决此问题，以确保它在从-viewWillDisappear：返回之前完成。 但是，由于NSThread中的实现细节含糊不清，因此不能保证可以解决此问题。<br>当您使用键值观察（KVO）来观察NSOperation的isFinished属性时，可能会出现类似的问题。 尽管KVO既不保留观察者也不保留被观察者，但即使您在-viewWillDisappear：方法中删除了观察者，仍然有可能，一个KVO通知可能已经在为您的对象运行。 如果发生这种情况，运行通知的线程可能最终会调用一个释放对象！<br>在一般情况下解决此问题非常棘手。 但是，如果您限制使用NSOperation，则有两种相对简单的解决方案路径：在持久对象中进行所有键值的观察，一个永不释放的对象</p>
<h2 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h2><p>NSOperation支持两种类型的操作：标准操作-这些操作（也称为非并发操作）要求NSOperationQueue代表它们提供并发性。  NSOperationQueue组织在线程上运行此类操作。<br>并发操作-这些操作带来自己的并发性。  NSOperationQueue不必专用于运行此类操作的线程。<br>当基础设施同步时，标准操作是异步运行任务的好方法。 它们通常用于长时间运行的计算，但对于快速，可靠的I / O（如磁盘I / O）也很有用。<br> 相反，当基础设施是异步的时，并发操作非常好-毫无用处地捆绑线程以等待异步API完成。 并发操作的一个很好的例子是使用NSURLConnection API执行HTTP请求的操作。<br> 正确实现并发操作有些棘手<br>重要说明：NSOperation的优点在于，它允许您抽象地对异步操作进行建模，而无需考虑基础实现技术。 您的高级代码只是开始操作并等待它完成。 不管操作实际上是如何完成工作的。 例如：</p>
<ul>
<li>该操作可能在线程上运行</li>
<li>该操作可能异步运行，由于某些基于运行循环的API而引起</li>
<li>该操作可能异步地运行，由于某些基于GCD的API而引起</li>
<li>该操作可能在单独的进程中运行</li>
</ul>
<p>此外，该操作可以更改其运行方式，而无需更改高级代码。 如果想更改以调用Web服务执行添加将非常容易。 只需要更改AdderOperation即可； 高级代码将完全相同。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>一些执行不当的操作会在实际完成之前触发isFinished的KVO通知。 如果使用KVO来确定操作是否完成，则最好获取isFinished属性并在继续操作之前确认操作已完成，即使只是在调试时声明中也是如此。 </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>

  






    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Rick Li
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>