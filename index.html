<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Coding</title>

  
  <meta name="author" content="Rick Li">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Coding"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Coding" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Coding</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/02/VM-Page-Swap/"><span>虚拟内存，分页和交换</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/VM-Page-Swap/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T03:37:43.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h2><p>虚拟内存是一种使用硬件（MMU）和软件（操作系统）实现的内存管理技术。 通过引入虚拟地址空间的概念，它从系统上可用的实际内存中抽象出来，该概念允许每个进程将物理内存视为连续的地址空间（或连续的段的集合）。<br>虚拟内存的目标是将执行程序生成的虚拟内存地址映射到计算机内存中的物理地址。 这涉及两个主要方面：地址转换（从虚拟到物理）和虚拟地址空间管理。</p>
<ul>
<li>地址转换:前者通过称为内存管理单元或MMU的特定硬件元素在CPU芯片上实现。</li>
<li>虚拟地址空间管理:由操作系统提供，设置虚拟地址空间（即，用于所有进程的单个虚拟空间或用于每个进程的一个虚拟空间），并实际将实际内存分配给虚拟内存。</li>
</ul>
<blockquote>
<p>此外，操作系统内的软件可以提供虚拟地址空间，该虚拟地址空间可以超过主存储器的实际容量（即，也使用辅助存储器），因此可以引用比系统中物理上存在的更多的存储器。</p>
</blockquote>
<p> 虚拟内存的主要好处包括：使应用程序（和程序员）不必管理共享的内存空间；由于内存隔离而提高了安全性；以及使用分页技术，在概念上可以使用比物理上可用的更多的内存。 实际上，几乎每种虚拟内存实现都将虚拟地址空间划分为连续的虚拟内存地址块，称为页面，通常大小为4 KB。<br>为了将进程的虚拟地址转换为硬件用来实际处理指令的物理内存地址，MMU使用了所谓的页表，即由OS管理的数据结构，用于存储虚拟地址和物理地址之间的映射 。<br>具体而言，MMU存储了整个OS页表中存储的映射中最近使用的映射的缓存，这称为转换后备缓冲区（TLB）。<br>下图描述了如上所述的地址转换任务。<br><img src="/2021/05/02/VM-Page-Swap/mmu.jpeg" alt="mmu"><br>当虚拟地址需要转换为物理地址时，MMU首先在TLB缓存中搜索它（上图中的步骤1.）。 如果找到匹配项（即TLB命中），则返回物理地址，然后继续进行计算（2.a.）。 相反，如果在TLB高速缓存中虚拟地址不匹配（即TLB未命中），则MMU在整个页表中搜索匹配，即页面遍历（2.b.）。 如果页表上存在此匹配项，则将其相应地写入TLB缓存（3.a.）。 因此，地址转换将重新启动，以便MMU能够在更新的TLB（1＆2.a.）上找到匹配项。<br>不幸的是，页表查找可能由于两个原因而失败。 </p>
<ul>
<li>第一个是指定的虚拟地址没有有效的转换时（例如，当进程尝试访问它无法请求的内存区域时）。 </li>
<li>否则，如果此时未将请求的页面加载到主存储器中，则可能会发生这种情况（相应页面表条目上的相应标志指示这种情况）。 </li>
</ul>
<p>在这两种情况下，控件都从MMU（硬件）传递到页面管理器（操作系统内核的软件组件）。 在第一种情况下，页面管理程序通常会引发分段错误异常（3.b.）。 在第二种情况下，发生页面错误（3.c.），这意味着必须从当前存储该页面的辅助存储（即磁盘）中检索请求的页面。 因此，页面管理器访问磁盘，将与引起页面错误的虚拟地址相对应的页面重新存储在主存储器中（4.），并使用虚拟地址和物理地址之间的新映射来更新页面表和TLB。 地址已存储页面的位置（3.a.），最后告诉MMU重新开始该请求，以便发生TLB命中（1＆2.a.）。<br>事实证明，上述任务一直有效，直到主内存中有足够的空间来存储从磁盘返回的页面为止。 </p>
<blockquote>
<p>但是，当所有物理内存都用完时，页面管理器还必须释放主内存中的页面以允许存储来自磁盘的传入页面。 </p>
</blockquote>
<p>为了公平地确定要从主内存移动到磁盘的页面，页面调度管理程序可以使用几种页面替换算法，例如最近最少使用（LRU）。 一般而言，将页面从/从辅助存储器移动到/从主存储器移动页面称为交换（4.），这就是为什么可能会发生页面错误的原因。<br> 现在让我们回到在典型的32位Linux操作系统上OS内核和用户模式虚拟内存空间之间的分离，这已在<a href="https://rickli.github.io/2021/05/01/Understanding-Memory-Layout/">程序（进程）的内存中布局</a>中介绍，并在下面进行了介绍。<br> <img src="/2021/05/02/VM-Page-Swap/memory_layout.jpeg" alt="memory_layout"><br> 这并不意味着内核会使用那么多物理内存。 相反，这只是虚拟地址空间的一部分，可用于映射OS内核希望的任何物理内存，并且它与可用物理内存的大小正交。 </p>
<blockquote>
<p>还要注意，在Linux中，内核空间一直存在，并且在所有进程中都映射相同的物理内存，这意味着内核空间不会改变，并且在任何进程上下文切换中都映射到相同的物理内存地址。</p>
</blockquote>
<p> 按照上面的拆分规则，内核具有专用的1 GB内核虚拟地址空间，并且无论它进行什么分配，它始终使用那些地址集。 虚拟地址到物理内存地址的实际映射完全通过硬件（即MMU）和软件（即OS页面管理程序）的组合进行了上述流程。<br>  假设系统X拥有512 MB的物理内存，则仅将整个1 GB虚拟空间中的512 MB映射为内核地址空间，而其余512 MB虚拟地址未映射。 另一方面，如果X具有2 GB的物理内存，则整个1 GB的虚拟地址将被映射到物理地址。<br> 如果整个内核都不适合物理内存，则拥有虚拟内存可以使OS内核页面部分驻留在辅助存储（即磁盘）上。 实际上，这种情况不会发生（至少在Linux上是这样），因为最新的Linux内核大约只需要70 MB，这大大低于当今现代系统上可用的物理内存量。 此外，内核具有的数据和代码出于效率原因必须始终保存在主存储器中，并且还因为无法以其他方式处理页面错误。 想一想在发生页面错误时我们上面讨论的内容：OS内核（实际上是OS页面管理程序）控制系统，输入特定的中断服务例程（ISR）来处理页面错误，并将控制权交还给 产生页面错误的用户进程。 如果OS内核不完全适合主内存，则可能发生内核本身生成页面错误的情况。 在非常糟糕的情况下，这种页面错误可能例如使页面与页面错误处理例程的代码有关，从而阻塞了整个系统！ 因此，内核代码和数据始终是可寻址的（即，它永远不会产生页面错误），并随时可以处理中断或系统调用。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/02/Multiprogramming-Multiprocessing-Multitasking-Multithreading/"><span>多程序，多处理，多任务和多线程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/Multiprogramming-Multiprocessing-Multitasking-Multithreading/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T03:12:47.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当您使用操作系统概念时，可能会有一些令人困惑的术语，看起来很相似，但实际上是指不同的概念。<br>在本文中，我将尝试阐明经常引起困惑的四个此类术语：多程序设计，多处理，多任务和多线程。<br>在现代计算系统中，通常有多个并发的应用程序进程争用（很少）资源，例如CPU。 正如我们已经介绍的那样，操作系统（OS）除其他职责外，还负责有效和高效地分配这些资源。 一般来说，处理资源分配的OS模块称为调度程序。 根据要实现的OS的类型，可以实现不同的调度策略。</p>
<h2 id="多程序设计"><a href="#多程序设计" class="headerlink" title="多程序设计"></a>多程序设计</h2><p>在多程序系统中，主存储器中已加载一个或多个准备执行的程序。</p>
<p>一次只有一个程序能够使CPU执行其指令（即，系统上最多有一个进程正在运行），而其他所有程序都在等待它们的执行。</p>
<p>多程序设计的主要思想是最大限度地利用CPU时间。 假设当前正在运行的进程正在执行I / O任务（根据定义，它不需要完成CPU）。 然后，OS可能会中断该进程并将控制权交给准备执行的其他主内存程序之一（即进程上下文切换）。 这样，系统不会在等待I / O任务完成之前浪费CPU时间，并且运行的进程会一直执行，直到它自愿释放CPU或阻塞以进行I / O操作为止。 </p>
<p>因此，多程序设计的最终目标是只要有准备好执行的进程，就能使CPU保持忙碌状态。</p>
<p>请注意，为了使这样的系统正常运行，操作系统必须能够将多个程序加载到主内存的单独区域中，并提供所需的保护，以避免一个进程被另一个进程修改的机会。 </p>
<p>当程序中有多个程序进入或离开主存储器时，在内存中有多个程序时需要解决的其他问题是碎片化。</p>
<p>同样需要处理的另一个问题是大型程序可能无法一次放入内存中，这可以通过使用分页和虚拟内存来解决。 请参考<a href="https://rickli.github.io/2021/05/02/VM-Page-Swap/">这篇文章</a>，以获取更多详细信息。<br>最后，请注意，如果有N个就绪的进程，并且所有进程都受到CPU高度限制（即，它们大部分执行CPU任务，并且没有I / O操作或很少有I / O操作），那么在最坏的情况下，一个程序可能会等待所有其他程序 N-1个要在执行之前完成。</p>
<h2 id="多处理"><a href="#多处理" class="headerlink" title="多处理"></a>多处理</h2><p>多处理有时是指同时执行多个进程（程序）。 这可能会引起误解，因为我们之前已经引入了“多程序”一词来描述。</p>
<p>实际上，多处理是指硬件（即CPU单元）而不是软件（即正在运行的进程）。 如果底层硬件提供了多个处理器，那么这就是多处理。 存在基本方案的几种变型，例如，一个管芯上的多个核或一个封装中的多个管芯或一个系统中的多个封装。</p>
<p>无论如何，可以通过使多个程序同时运行来对系统进行多程序处理，也可以通过具有一个以上的物理处理器来对系统进行多处理。多核CPU可以同时执行多个进程。</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>多任务处理具有与多程序设计相同的含义，但是从更一般的意义上讲，因为它指的是同时运行多个（程序，进程，任务，线程）。 当多个任务共享一个共同的处理资源（例如，CPU和内存）时，该术语在现代操作系统中使用。 </p>
<p>在任何时候，CPU仅在其他任务等待轮流执行时才执行一个任务。当将CPU重新分配给另一个任务时（即进程或线程上下文切换），就可以实现并行性的错觉。</p>
<p>多任务和多编程之间存在细微的差异。 多任务操作系统中的任务不是整个应用程序，但是当一个进程分为子任务时，它也可以称为“执行线程”。 每个较小的任务都不会像以前的多程序一样完成CPU的劫持，而是占用相当一部分的CPU时间（称为量子）。</p>
<p>为了易于记忆，多程序和多任务操作系统都是（CPU）时间共享系统。 </p>
<p>但是，在多程序（较旧的OS）中，一个程序作为一个整体会一直运行直到阻塞为止，而在多任务（现代OS）中，时间共享是最好的体现，因为每个运行的进程仅占用相当一部分CPU时间。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>到现在为止，我们已经讨论了多程序设计，它是一种允许多个程序驻留在主内存中并且（显然）同时运行的方法。 然后，多任务处理是指通过共享CPU时间同时（显然）同时运行的多个任务。 最后，多核处理描述了具有多个CPU的系统。 那么，多线程从何而来呢？</p>
<p><strong>多线程</strong> 是一种执行模型，它允许单个进程在该进程的“上下文”内同时运行多个代码段（即线程）。 您可以将线程视为共享父流程资源但独立执行的子流程。 </p>
<p>单个进程的多个线程可以在单个CPU系统中共享CPU，或者（完全）在多处理系统中并行运行。为什么我们需要在单个进程上下文中拥有多个执行线程？</p>
<p>好吧，例如考虑一个GUI应用程序，用户可以在其中发出需要很长时间才能完成的命令（例如，复杂的数学计算）。 除非您将此命令设计为在单独的执行线程中运行，否则您将无法与主应用程序GUI进行交互（例如，更新进度条），因为在进行计算时该命令将无响应。</p>
<p>当然，设计多线程/并发应用程序需要程序员处理开发单线程顺序应用程序时根本不会发生的情况。 例如，当两个或多个线程尝试访问和修改共享资源（竞争条件）时，程序员必须确保这不会使系统处于不一致或死锁状态。 通常，此线程同步是使用OS原语（例如互斥体和sempaphores）解决的。</p>
<h3 id="有关上下文切换的附带说明"><a href="#有关上下文切换的附带说明" class="headerlink" title="有关上下文切换的附带说明"></a>有关上下文切换的附带说明</h3><p>上下文切换的概念适用于多程序设计以及多任务，但粒度不同。 在前者中，“上下文”是指整个过程的上下文，而在后者中，“上下文”可能是较轻的线程的上下文。 实际上，进程上下文切换涉及切换虚拟内存地址空间：这包括内存地址，映射，页表和内核资源。 另一方面，线程上下文切换是在同一进程中从一个线程切换到另一个线程的上下文切换（即，无需切换虚拟内存地址空间，因为“切换器”和“切换者”线程共享相同的虚拟地址空间）  ）。 这需要切换处理器状态（例如程序计数器和寄存器内容），这通常非常有效。<br>当然，跨不同进程在线程之间切换就像进程上下文切换一样。</p>
<h2 id="Program-vs-Process"><a href="#Program-vs-Process" class="headerlink" title="Program vs. Process"></a>Program vs. Process</h2><p>实际上，这是一个“微妙”的问题，因为有时会误将这两个术语用于指代相同的概念。<br>此外，这是面试官在您申请软件工程师职位时可能会提出的“经典”问题之一。<br> 简而言之，程序是一个可执行文件，驻留在辅助持久性存储器（即磁盘）上，并且仅包含完成特定工作所需的指令集。 例如，ls程序是一个可执行文件，存储在运行类Unix操作系统的系统磁盘上的/ bin / ls中。<br>相反，当被加载到主存储器时，进程是程序的特定执行实例，即，在程序内收集的那些指令的实际执行。 例如，您可能在上面的ls程序中有多个正在运行的实例，因此同一程序有多个进程。 事实证明，可以将程序视为“静态/被动”实体，而将流程视为“动态/主动”实体。<br> 通常，一个进程由以下资源组成：<br> –内存，包括可执行代码的映像，特定于进程的数据（输入和输出），调用堆栈（以跟踪活动子例程和/或其他事件）， 还有一个堆，用于保存在运行时生成的中间计算数据。<br>–分配给进程的资源的操作系统描述符，例如文件描述符（Unix术语）或句柄（Windows）。<br>–安全属性，例如流程所有者和流程的权限集。<br>–处理器状态（即上下文），例如寄存器的内容，物理存储器的寻址等。状态通常在进程执行时存储在计算机寄存器中，否则存储在主存储器中。<br>操作系统将有关活动进程的大多数此类信息保存在称为“进程控制块（PCB）”的数据结构中。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/Library-Difference/"><span>静态库、动态库、Swift Package？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/Library-Difference/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T06:43:18.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>每个开发人员都知道在项目中支持干净架构的重要性。 偏好模块化代码库以独占应用程序的原因显而易见。 它们是命名空间，访问控制，在不同的模块中使用不同的编程语言。 当然，还有代码重用。</p>
<p>在本文中，我们将讨论基于iOS Swift的项目中支持模块化代码库的选项，其中包括：</p>
<ul>
<li>librarys; </li>
<li>框架，包括新的XCFramework bundle类型；<br>Swift软件包。<br>尽管仅限于iOS，但这并不意味着您不能在其他Apple平台上使用这些方法。<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3>Swift中基于<a target="_blank" rel="noopener" href="https://swift.org/package-manager/">模块</a>的代码组织和访问控制的概念。 该模块表示为单个代码分发单元。 在Xcode中将框架，库，快速包和构建目标视为单独的模块。 每个都有其命名空间和访问控制。 通常，模块可以解决特定问题。 它可以在不同情况下重用。</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/bundle">Bundle</a></strong> 是一个文件目录，其中包含子目录。 在iOS上，bundle包用于将相关文件方便地一起打包到一个包中，例如图像，nibs或编译后的代码。 系统将其视为一个文件，您可以在不知道其内部结构的情况下访问Bundle资源。 无法链接的Dylib，只能在运行时使用<code>dlopen()</code>打开</p>
<p><strong>源文件</strong> 是模块中的单个Swift源代码文件。<br><strong>可执行文件</strong> 应用程序的主要二进制文件。<br><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_file#targetText=An%20object%20file%20is%20a,work%20like%20a%20shared%20library.">目标文件</a></strong> 目标文件是包含<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_code">目标代码</a>的文件，这意味着通常无法直接执行的可重定位格式的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Machine_code">机器代码</a>。 目标文件也可以像<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_library">共享库</a>一样工作。<br><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_code">目标代码</a></strong> 在计算中，目标代码或目标模块是编译器的产物。 在一般意义上，目标代码是计算机语言，通常是机器代码语言（即，二进制或中间语言，例如寄存器传送语言）中的一系列语句或指令。</p>
<h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>在计算机科学中，库意味着将资源和代码收集到一个或多个体系结构中。 使用iOS应用程序时，您将面临静态和动态库。 让我们来看看它们是什么。<br><strong><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">静态库</a></strong> (*.a) （<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">静态归档库</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">静态链接</a>的共享库）—目标文件的集合或归档。 静态链接器将带有库代码的应用程序编译的源代码收集到单个可执行文件中，该文件在运行时全部加载到内存中。<br><img src="/2021/05/01/Library-Difference/link_static_library_memory_usage.png" alt="Linking static library and memory usage"><br>由于静态库在一般意义上是机器代码语言中的一系列语句或指令，因此添加了一些限制来创建和分发它们：您需要为与客户端代码相同的处理器体系结构构建一个库。  。 例如，如果您正在为iOS应用程序使用库，则需要为iOS Simulator和iOS设备创建一个库。</p>
<p>该库不能包含资源文件：图像，assets，nibs，字符串文件和其他可视数据。 如果要包括工程的这些资源，则这些资源将与.a文件分开。 通常，作为解决此问题的方法，所有方法都与另一个独立bundle包中提供的外部资源有关。</p>
<p>您可以创建一个Swift静态库，这是Xcode 9.0支持的。 Xcode 9支持了动态框架。 使用CocoaPods的开发人员请记住，添加use_frameworks是必需的。 它告诉CocoaPods您想使用Frameworks而不是Static Libraries，因为Swift不支持它。 但是幸运的是，Swift和Xcode一直在不断改进，现在我们已经支持Swift静态库。</p>
<p>静态库的格式在Windows下为.lib，在Linux或Mac下为.a。 整个静态库将被加载到目标文件中，并在编译期间保持静止。 静态库的好处是目标程序可以不受任何外部依赖地运行，即，您可以根据需要将此程序复制到其他系统。 但是缺点是它将使程序变大。</p>
<p><strong>动态库</strong>  (*.dylib)（<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">动态共享库</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">共享对象</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">动态链接库</a>）不会像静态库一样复制到可执行文件中。 相反，当二进制文件和库都在内存中时，它们会在加载或运行时动态链接。 动态库分别存储和版本控制。 结果，如果更新被认为与原始版本二进制兼容，则动态库可能加载的内容与原始引用的内容不同。<br><img src="/2021/05/01/Library-Difference/link_dyld_memory_usage.png" alt="link_dyld_memory_usage"><br>系统iOS和macOS库是动态的。 这意味着您的应用将获得Apple更新的改进，而无需提交新的版本。 这也可能导致互操作性问题。 因此，在新版OS发行前测试该应用程序始终是个好主意。<br>关于iOS应用程序自己的自定义.dylib的创建和集成，有一些旧的讨论：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48209855/xcode-9-no-option-to-create-dylib-project-ios">topic1</a>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4733847/can-you-build-dynamic-libraries-for-ios-and-load-them-at-runtime">topic2</a>。 尽管如此，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/technotes/tn2435/_index.html#//apple_ref/doc/uid/DTS40017543-CH1-PROJ_CONFIG-APPS_WITH_DEPENDENCIES_BETWEEN_FRAMEWORKS">Apple文件</a>清楚地指出：</p>
<blockquote>
<p>除了Xcode提供的系统Swift库外，iOS，watchOS或tvOS上不支持框架捆绑包之外的动态库（通常具有文件扩展名.dylib）。</p>
</blockquote>
<p>动态库（Windows下为.dll，Linux下为.so，而Mac下为.dylib / .tbd）将不会加载到目标程序中。目标程序仅在编译短语期间加载引用。 动态库将在运行时加载。<br>无需重新编译整个程序即可轻松升级Dynamic库</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><blockquote>
<p>框架（.framework）：是一个分层目录，它将动态库，头文件和资源（例如storyboards，图像文件和本地化的字符串）封装到一个包中。 使用框架的应用程序需要将框架嵌入到应用程序包中。<br>旨在与静态和动态共享库相同的目的的框架。 但是与库不同，框架：</p>
</blockquote>
<ul>
<li>可以包含图像，assets，文档，字符串文件之类的资源。</li>
<li>仅将一个框架只读资源的副本加载到内存中，从而可以减少内存占用并在iOS应用程序和扩展之间共享框架。<br>关于框架和库之间的区别还有另一种观点，这是基于架构师和简洁设计的观点。 <a target="_blank" rel="noopener" href="https://martinfowler.com/">马丁·福勒（Martin Fowler）</a>在精彩的文章“<a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/InversionOfControl.html">控制反转</a>”中说，控制反转是使框架与库不同的关键部分：</li>
<li>该库本质上是可以调用的一组函数，这些天通常组织成类。 每个调用都会执行一些工作，并将控制权返回给客户端。</li>
<li>框架体现了一些抽象设计，并内置了更多的行为。要使用它，您需要通过子类化或插入自己的类将行为插入框架中的不同位置。 然后，框架的代码将在这些位置调用您的代码。 程序的主控件被反转，从您移至框架。<br>在iOS 8之前，Apple不允许使用Dynamic Framework。 引入动态框架可能是因为Apple开始支持扩展的原因。 使用扩展程序，必须拥有与相应应用程序中使用的相同的框架。<br>iOS 8才开始支持的Dynamic 框架。</li>
</ul>
<p>在iOS中，Apple使用Framework打包头文件，源文件，二进制文件和资源。 同样，框架可以分为静态框架和动态框架。</p>
<p>关于框架的讨论也值得一提的是伞形框架和通用框架（胖框架）：伞形框架：是包含其他框架的框架包。 伞框架可用于macOS应用程序，但Apple不建议使用它们。  iOS，watchOS或tvOS不支持伞框架。</p>
<p>通用框架（fat框架）：多体系结构二进制文件，其中包含本机针对多个指令集的代码，并且可以在多种处理器类型上运行。 简而言之，它包含为您要支持的所有平台编译的代码。 例如，用于设备的x86_64（64位模拟器），arm64 arm64e armv7 armv7s。 结果，这样的框架将比一个架构的框架具有更大的规模。 有很多关于如何使用lipo制作通用框架的教程。 此方法广泛用于共享私有二进制文件。 这样，您的框架使用者就可以在真实的设备和模拟器上使用您的框架。</p>
<p>您可以在终端中使用file命令获得框架：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;PathToAppFramework&gt;/&lt;FrameworkName&gt;.framework/&lt;FrameworkName&gt;</span><br></pre></td></tr></table></figure>
<p>要将所有动态链接的框架和库检查为二进制文件，可以使用otool：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -L &lt;PathToArchive&gt;/Products/Applications/&lt;AppName&gt;.app/&lt;AppBinary&gt;</span><br></pre></td></tr></table></figure>
<p>苹果表示，APP平均包含100-400个系统dylib。 系统框架的加载已高度优化。 但是加载自定义嵌入式框架可能会很昂贵。  Apple的工程师鼓励您明智地使用框架，并限制框架的使用量，因为这会影响应用程序的启动时间。 如果您对框架的工作原理及其对应用程序启动时间的影响感兴趣，请查看WWDC会话“<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/406/">优化应用程序启动时间</a>”。</p>
<p>苹果公司宣布Swift 5为应用程序提供二进制兼容性，这意味着使用一个版本的Swift编译器构建的应用程序将能够与使用另一个版本的库进行通信。 目前，Swift的ABI已宣布在Apple平台上对Swift 5稳定。</p>
<h3 id="XCFrameworks"><a href="#XCFrameworks" class="headerlink" title="XCFrameworks"></a>XCFrameworks</h3><p>XCFrameworks是一种新的受支持的分发二进制框架的方法，可从Xcode 11获得。实际上，该框架现在可以包含用于多个体系结构和平台的代码。 您仍然需要为不同的平台生成存档，并将它们捆绑在一起在单个XCFrameworks中。  WWDC 2019有一个很棒的会议：<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/416/">Swift中的二进制框架</a>，详细解释了如何创建，集成和分发XCFrameworks</p>
<p>使用XCFrameworks的优点很少：</p>
<ul>
<li>XCFramework不仅包含针对设备和模拟器的变体，而且还包含针对Xcode支持的任何平台的变体：iOS，macOS，tvOS，watchOS； </li>
<li>它支持Swift和基于C的代码； </li>
<li>可以打包框架和静态库。<br>借助Xcode 12中的新软件包清单API，现在可以制作包含一个或多个XCFrameworks的Swift软件包。 您可以在官方文档以<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift_packages/distributing_binary_frameworks_as_swift_packages">Swift软件包分发二进制框架</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10147/">WWDC 2020视频</a>中找到实现的详细信息。</li>
</ul>
<h3 id="Swift-Package"><a href="#Swift-Package" class="headerlink" title="Swift Package"></a>Swift Package</h3><p>Swift是一种跨平台语言，需要用于构建Swift代码的跨平台工具。  <a target="_blank" rel="noopener" href="https://swift.org/package-manager/#targetText=The%20Swift%20Package%20Manager%20is,in%20Swift%203.0%20and%20above.">Swift软件包管理器</a>（SwiftPM）的目标之一是简化Swift生态系统中的分发源代码。  SwiftPM是一个开源项目，您也可以在<a target="_blank" rel="noopener" href="https://github.com/apple/swift-package-manager">GitHub</a>上找到有关它的信息。<br>Swift Package包含源文件和清单文件（Package.swift）。 清单描述了Swift软件包的配置。  Swift Package是由<a target="_blank" rel="noopener" href="https://swift.org/package-manager/">Swift Package Manager</a>定义和使用的，其中包括<a target="_blank" rel="noopener" href="https://swift.org/package-manager/">Swift 3.0及更高版本</a>。 由于以源代码形式分发，因此不再需要维护客户端的二进制兼容性。 因此，如果您可以交付源代码，那么Swift Package是您的理想工具。 借助Xcode 11中的新更改，您可以轻松创建和分发Swift软件包。</p>
<p>Swift软件包包括3个部分：依赖项，目标和产品：</p>
<p>__依赖关系__：您在包内部使用的其他swift包。 在软件包文件中，每个依赖项都由源位置和版本指定。</p>
<p>__目标__：如Apple的文档所述，<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/creating_a_swift_package_with_xcode">目标是包的基本组成部分</a>。既可以是库，也可以是可执行文件。 在Xcode 12 Swift软件包之前，只能包含Swift，Objective-C / C ++或C / C ++文件。  Xcode 12提供了新的tools-version：5.3，它带来了新的包清单API。 现在，Swift包可以包含其他资源类型：图像，storyboards，JSON文件，Shell脚本等等。 您还可以本地化这些资源。 这是很棒的，希望得到改进。 感谢所有为提供此功能做出贡献的人。 有用的详细信息和实现详细信息，可以在WWDC 2020视频Swift包中找到：<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10169/">资源和本地化</a>，以及在文档<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift_packages/localizing_package_resources">Localizing Package Resources</a>中。</p>
<p>__产品__：软件包的输出，可以是软件包产生的库或可执行文件，并使它们对其他软件包可见。</p>
<p>下面是Swift软件包的优缺点:<br>优点：</p>
<ul>
<li>1.由Xcode管理的依赖关系； </li>
<li>2.由Xcode管理的版本； </li>
<li>3.无需二进制兼容性，可以在同一构建操作中针对多个平台编译软件包。 不再需要为每个平台创建单独的框架目标。 </li>
<li>4.源代码形式的分发允许检查代码并在调试时介入其中。</li>
<li>5.查看Xcode 12 Swift软件包可以包含图像，storyboards，XCFrameworks和更多其他文件类型。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1.（仅在Xcode 12之前）Swift软件包包含源代码，但不支持资产和资源。</li>
<li>2.（仅在Xcode 12之前）Swift程序包只能依赖于其他Swift程序包，不支持二进制依赖性。</li>
<li>3.源代码形式的分发不适用于不想共享源代码的框架提供程序。</li>
</ul>
<p>显然，在为iOS应用程序选择静态库，框架或Swift包之间的体系结构时，应考虑每个特定项目的局限性。</p>
<p>将太多的静态库链接到应用程序中会产生较大的应用程序可执行文件，启动时间较慢，并且内存占用量很大。 与静态库相比，框架可以为您提供更多的灵活性，它们可以包含资源。 但是，添加到项目中的每个嵌入式框架也会增加启动时间。<br>如果您可以发送源文件，则Swift软件包可能是您的正确选择。  Xcode将处理所有依赖项，版本控制和平台。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>库是一个已编译的库文件，通常为二进制格式。 其他用户可以直接将其与一个或多个头文件一起使用。<br>库有两种类型：</p>
<ul>
<li>1.静态库</li>
<li>静态链接。 相关代码和地址将立即加载到主程序中。</li>
<li>它将使程序大小变大。</li>
<li>2.动态库</li>
<li>动态链接。 相关代码和地址将被计算，然后加载到主程序中。 此计算将有额外的时间。</li>
<li>与静态库相比，动态库可以由一个副本用于多个程序。不会使程序大小变大。无需重新编译整个程序即可轻松升级Dynamic库</li>
<li>缺点1:动态库/库上的额外编译时间</li>
<li>缺点2:当您尝试将程序复制到其他系统但忘记了动态库时，很容易得到诸如在Linux下的“找不到库”之类的错误</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/Understanding-Memory-Layout/"><span>Understanding Memory Layout in iOS</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/Understanding-Memory-Layout/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T06:04:27.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>内存是指存储信息以供计算机立即使用的计算机硬件集成电路。 计算机内存用于存储位模式。 不仅数据而且指令也是位模式，这些位模式可以存储在存储器中。 在系统软件中，它们存储在单独的内存段中。 这些段也按数据和程序类型进行划分。</p>
<p>多任务OS在虚拟地址空间中运行。 在64位系统的情况下，内存地址分配了8个字节，对于32位系统，分配了4个字节，对于16位系统，分配了2个字节。 此值称为地址大小，CPU可寻址的最小单位为1字节（8位）。</p>
<p>程序运行时，将在系统上称为内核空间和用户空间的两个空间中执行处理。 这两个处理空间彼此隐式地相互干扰，并且程序的处理继续进行。</p>
<ul>
<li><strong>内核空间</strong><br>用户进程只能通过使用系统调用来访问内核空间，这些系统调用是类Unix操作系统中的请求，例如输入/输出（I / O）或进程创建。</li>
<li><strong>用户空间</strong><br>用户空间是分配给用户的计算资源，并且是执行程序可以直接访问的资源。 该空间可以分为几个部分。<h3 id="程序中的内存布局"><a href="#程序中的内存布局" class="headerlink" title="程序中的内存布局"></a>程序中的内存布局</h3>下图显示了内核空间和用户空间的虚拟内存空间。 虚拟空间的用户空间部分分为栈和堆，BSS，数据，文本。<br><img src="/2021/05/01/Understanding-Memory-Layout/memory_lauout.png" alt="memory layout"><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4>栈空间位于OS内核空间的正下方，通常与堆区域相对，并向下扩展到较低的地址。  （在其他一些架构上可能会朝相反的方向发展）<br>栈是LIFO（后进先出）数据结构。 在计算机科学中，栈是一种抽象数据类型，它是元素的集合，具有两个主要操作：</li>
<li>push（将元素添加到集合中）</li>
<li>pop（弹出）将删除最近添加的尚未删除的元素。<br>该区域专用于在程序中存储函数调用所需的所有数据。 调用函数与将被调用函数的执行推入栈顶部相同，一旦该函数完成，将返回结果，将函数从堆栈中弹出。 推送给函数调用的数据集称为栈帧，其中包含以下数据。</li>
<li>传递给常规程序的参数（参数值）</li>
<li>将返回地址返回给例程的调用方，</li>
<li>程序的局部变量分配的空间<br>以下是C程序的示例和栈存储器分配的图片。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = getResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = getNum1();</span><br><span class="line">  <span class="keyword">int</span> num2 = getNum2();</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
调用该函数时，栈帧被推到栈的顶部。 然后执行该过程，函数超出范围，栈帧从顶部弹出。<br><img src="/2021/05/01/Understanding-Memory-Layout/stack_pop_flow.png" alt="stack_pop_flow"><br>如上所述，它只能存储有限范围的数据。 但是，在内存管理中，它运行非常快，因为栈指针寄存器仅跟踪栈的顶部。<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4>堆是通常进行动态内存分配的段。 该区域通常从BSS段的末尾开始，然后向上扩展到更高的内存地址。 在C语言中，它由malloc / new，free / delete管理，后者使用brk和sbrk系统调用来调整其大小。<br>在以下情况下，将分配到堆区域。</li>
<li>内存大小在运行时动态分配</li>
<li>范围不受限制。  （例如，从多个地方引用的变量）</li>
<li>内存大小非常大。<br>释放堆内存是我们的责任。 如果不释放堆中的对象，则会导致内存泄漏。 在垃圾回收语言中，垃圾回收器释放堆上的内存并防止内存泄漏。</li>
</ul>
<p>可以通过重复分配和释放区域来在堆上生成未使用区域。 将“未使用的节点”和“正在使用”的节点混合的状态，即未使用区域被垃圾分割成碎片的状态称为碎片状态。 在这种状态下，搜索可用空间的开销以及数据“参考位置”的性能下降，因此性能相对较低。</p>
<h4 id="BSS（Block-Started-by-Symbol）"><a href="#BSS（Block-Started-by-Symbol）" class="headerlink" title="BSS（Block Started by Symbol）"></a>BSS（Block Started by Symbol）</h4><p>未初始化的数据段，通常称为BSS段。 在程序开始执行之前，内核将此段中的数据初始化为算术0。 例如，声明为static int i的变量； 将分配给BSS段。</p>
<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>数据段包含已初始化的全局变量和静态变量，这些变量具有预定义的值并且可以修改。 它分为只读空间和读写空间。<br>例如下面的C程序main函数外</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><p>存储机器语言指令的段。 该段是只读空间。</p>
<h4 id="Stack-vs-Heap"><a href="#Stack-vs-Heap" class="headerlink" title="Stack vs Heap"></a>Stack vs Heap</h4><p>栈速度更快，因为所有可用内存始终是连续的。 与堆不同，没有列表需要保留所有可用内存的列表，只有一个指针指向栈的当前顶部。 栈中的每个字节都倾向于被非常频繁地重用，这意味着它倾向于被映射到处理器的高速缓存中，从而使其非常快。 因此，只要您不需要使用堆，我建议您使用栈。</p>
<h4 id="系统动态库所在的内存布局呢"><a href="#系统动态库所在的内存布局呢" class="headerlink" title="系统动态库所在的内存布局呢"></a>系统动态库所在的内存布局呢</h4><p>TODO</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_segment">Data Segment</a><br><a target="_blank" rel="noopener" href="https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/in-memory-layout/">In-Memory Layout of a Program (Process)</a><br><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/memory-layout-of-c-program/">Memory Layout Of C Program</a><br><a target="_blank" rel="noopener" href="https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/lec/08/lec.html">Memory Alloc And Program Memory Layout</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/Mach-O-Executable/"><span>Mach-O Executable</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/Mach-O-Executable/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T04:09:36.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>我想谈谈这个神秘的词Mach-O…<br>它是什么？<br>它是如何工作的？</p>
<p>为了解决所有这些问题，我们必须亲自动手深入挖掘…</p>
<p>当我们使用Xcode构建APP时，很多事情同时发生。 其中之一是将所有源代码转换为可执行文件。 该可执行文件包含将在CPU，iOS设备上的ARM处理器或Mac上的英特尔处理器上运行的字节码。</p>
<p>该可执行文件称为Mach-O。</p>
<h2 id="Mach-O-格式"><a href="#Mach-O-格式" class="headerlink" title="Mach-O 格式"></a>Mach-O 格式</h2><p>Mach-O是字节的二进制流，被分成有意义的数据块。 这些块包含有关元数据的信息，例如字节顺序，CPU类型，块大小等。</p>
<p>Mach-O有多种类型，最典型的是您会看到这些：</p>
<ul>
<li>可执行文件 主APP二进制文件，例如Example.app/Example</li>
<li>Dylib 动态库，例如libSwiftCore.dylib<br>因此，Mach-O文件分为几个部分，看起来像这样<br><img src="/2021/05/01/Mach-O-Executable/mach_binary.png" alt="mach binary"><br>但在深入探讨分段之前，我们先来看看其他内容</li>
</ul>
<h3 id="Mach-O-Header"><a href="#Mach-O-Header" class="headerlink" title="Mach-O Header"></a>Mach-O Header</h3><p><img src="/2021/05/01/Mach-O-Executable/Mach-O_header.png" alt="Mach-O header"><br>每个Mach-O文件都以定义文件结构的头结构开头。 它还包含有关文件类型和目标体系结构（armv7，armv7s，i386等）的信息。</p>
<p>头文件结构的正下方是一堆加载命令，这些命令有助于文件的布局和链接。 另外，加载命令可以指定</p>
<ul>
<li>文件在虚拟内存中的初始布局</li>
<li>Section名称和地址</li>
<li>要加载的dylib</li>
<li>“main”函数地址</li>
<li>代码签名<br>这就是完整的标题的样子！<br><img src="/2021/05/01/Mach-O-Executable/complete_header.png" alt="Mach-O complete header"><br>如您所见，Mach-O头文件由一堆加载命令组成，这些命令定义了各节的地址，主函数以及要加载的从属二进制文件。</li>
</ul>
<p>上面提到的地址实际上与加载Mach-O的内存地址有偏差。 这样做是因为每次启动APP时，都会使用一种称为“自动空间布局随机化”的精巧技术或我们亲切地称为ASLR的启动技术来对起始内存地址进行随机化。</p>
<p>这意味着您的APP进程启动时，您不知道它将从哪个地址开始启动。<br>让我们想象一下它的含义，假设您有一个全局变量，它占用了RAM中的某些内存地址，但是由于您不知道进程从何处开始，因此您可能无法确定该全局变量的内存地址！</p>
<p>您可能已经猜到，这样做是出于安全目的，否则，如果每次启动时所有地址都相同，那么破解二进制文件将变得非常容易！</p>
<h3 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h3><p>让我们看一下Mach-O文件的各个部分</p>
<h4 id="PAGEZERO"><a href="#PAGEZERO" class="headerlink" title="__PAGEZERO"></a>__PAGEZERO</h4><p>这是可执行文件的第一部分，内部没有数据，因此不占用文件空间。 该段充满零以捕获NULL指针取消引用。 您可能已经遇到了EXC_BAD_ACCESS崩溃，这恰恰是因为代码中的某些内容试图从此处访问数据，而这是不允许的。<br>顺便说一句，此段可能是隐藏恶意代码的好地方😉</p>
<h4 id="TEXT"><a href="#TEXT" class="headerlink" title="__TEXT"></a>__TEXT</h4><p>该段包含可执行代码和只读数据。 将该段设置为只读，以允许在将段映射到内存时共享该段。 这主要与框架，bundles和共享库一起使用。</p>
<p>并且，由于__TEXT段是只读的，因此不需要将任何更改保存回磁盘。 如果内核需要释放内存，它将仅删除__TEXT页面并在需要时重新读取它们。</p>
<p>这就是iOS和OSX如此积极地缓存其动态库的原因。</p>
<h4 id="DATA"><a href="#DATA" class="headerlink" title="__DATA"></a>__DATA</h4><p>该段包含可写数据（例如，全局变量，静态变量等），并且由于可写，因此逻辑上为与该库链接的每个进程复制框架或其他共享库的__DATA段。</p>
<p>如果您有使用Swift的经验，那么您必须熟悉写时复制，这实际上意味着在引用的内容进行编辑之前，不要创建副本。 同样，当复制__DATA段时，直到某个进程对其进行修改后，该进程才真正接收到它自己的页面私有副本。</p>
<h4 id="OBJC"><a href="#OBJC" class="headerlink" title="__OBJC"></a>__OBJC</h4><p>这是一个可选段，包含由Objective-C语言运行时支持库使用的数据。</p>
<h4 id="IMPORT"><a href="#IMPORT" class="headerlink" title="__IMPORT"></a>__IMPORT</h4><p>这也是一个可选段，包含符号存记录和指向可执行文件中未定义的符号的非惰性指针。 仅针对IA-32体系结构的可执行文件生成此段。</p>
<h4 id="LINKEDIT"><a href="#LINKEDIT" class="headerlink" title="__LINKEDIT"></a>__LINKEDIT</h4><p>该段包含链接器（链接编辑器）的原始数据，例如符号和字符串表，压缩的动态链接信息，代码签名信息以及间接符号表，所有这些数据均由装入命令指定的区域占据。</p>
<p>因此，既然我们已经了解了各个部分，那么让我们尝试着眼于大局，看看它们如何融合在一起。</p>
<h3 id="全局图—-DYLD"><a href="#全局图—-DYLD" class="headerlink" title="全局图— DYLD"></a>全局图— DYLD</h3><p>直到现在我们知道</p>
<ul>
<li>1、如何生成Mach-O文件，并使用其加载命令以各种方式链接依赖项。</li>
<li>2、加载命令用于映射内存命令中的段。</li>
<li>3、文件的执行从LC_MAIN开始<br>好吧，这仅仅是信息，而该信息需要大脑进行处理。这个大脑叫做Dyld！</li>
</ul>
<p>当您通过点击APP图标启动APP时，而不是启动您的APP，内核会启动dyld！<br>我知道，对吧！ 这个家伙在这里很重要。<br>内核实际上将在某些随机地址空间加载dyld，并且内核本身将具有自己的__TEXT段，__ DATA段……好了，您就知道了。<br><img src="/2021/05/01/Mach-O-Executable/dyld_loaded_in_RAM.png" alt="dyld loaded in RAM"><br>dyld的工作主要是为我们加载和设置所有依赖的dylib。</p>
<h4 id="加载-dylibs"><a href="#加载-dylibs" class="headerlink" title="加载 dylibs"></a>加载 dylibs</h4><p>dyld在此处读取Mach-O标头，以查找有关从属dylib的信息。 然后，它在文件系统上找到该库文件并对其进行解析。</p>
<p>此过程是递归完成的，因为dylib A可以依赖dylib B，而dylib B可以依赖dylib C，因此它必须解析整个依赖关系图，最后将所有这些dylib的段映射到原始Mach-O头文件中。</p>
<p>而且，整个处理可能看起来像这样。<br><img src="/2021/05/01/Mach-O-Executable/Multiple_dylibs_loaded.png" alt="Multiple dylibs loaded"><br>现在，请记住我们讨论过ASLR，以及如何不知道将哪个地址分配给APP中的所有变量。  dyld必须使用以下技术来解决此问题。</p>
<h4 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h4><p>__LINKEDIT部分包含所有需要移动的指针的位置。  Dyld将遍历所有这些指针，并根据您APP的起始地址对其进行移位。</p>
<p>请注意，要执行此操作，我们必须读取和写入数据页，从而导致这些页变脏，并且需要在写入时进行复制。 这就是为什么Rebasing在IO中非常昂贵的原因。</p>
<h4 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h4><p>对其他dylib函数的引用是使用绑定固定的，例如NSLog，malloc等。</p>
<p>dyld加载依赖库后，需要搜索符号表并找到这些符号的实现。<br>因此，二进制文件中实际上存在一个名为<code>_NSLog</code>的字符串，该字符串尚未解析，而dyld要做的是查找符号表，并用相关库中这些函数的地址填充该表。</p>
<p>这在计算上很复杂并且很昂贵</p>
<h4 id="Objc-Runtime"><a href="#Objc-Runtime" class="headerlink" title="Objc Runtime"></a>Objc Runtime</h4><p>所有Objc类定义都需要注册，为什么？ 因为您可以从调用<code>NSClassFromString(_:)</code>方法的字符串构造Objc类。</p>
<p>因此，dyld必须先构建此表，然后才能启动APP。</p>
<p>在类别中添加方法列表-这意味着，如果您已经在UIView上创建了一个类别并添加了许多新函数，则这些新函数将被添加到UIView的方法列表中。</p>
<p>它还可以确保<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11051528/understanding-uniqueness-of-selectors-in-objective-c/11052795#11052795">选择器是唯一</a>的。</p>
<h4 id="Run-Initializers"><a href="#Run-Initializers" class="headerlink" title="Run Initializers"></a>Run Initializers</h4><ul>
<li>此时将调用Objc <code>+ load</code>方法</li>
<li>C ++静态初始化程序<br>这是以自下而上的方式发生的，因此基本上将首先初始化从属库。<br>哇！ 完成所有这些操作之后，最后，您的<code>main()</code>将执行。<br>而且，这就是难以捉摸的Mach-O文件背后的故事。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>1、二进制文件使用带有__TEXT，__ DATA和__LINKEDIT段的Mach-O格式。</li>
<li>2、Dyld需要解析并加载所有动态库依赖项。</li>
<li>3、Dyld需要修复内部和外部的所有指针（变基，绑定，设置运行时）。</li>
<li>4、运行静态初始化程序和+ load方法。</li>
<li>5、然后<code>main()</code><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3></li>
<li>1、Dyld在您的APP启动之前运行。</li>
<li>2、避免使用+ load方法，它是已弃用的API，在<code>main()</code>增加APP启动时间之前调用。</li>
<li>3、对于App库，由于dyld必须完成每个dylib的所有解析，加载和修复工作，因此dylib将招致大量启动开销。 请改用静态库。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/iOS-APP-Launch-Explain/"><span>iOS APP 启动详解</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/iOS-APP-Launch-Explain/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T03:03:47.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>等待启动是任何APP提供的第一个用户体验。 APP的启动屏幕后面可能会发生很多事情，当然，它应该可以立即使用。 精美的动画只能吸引用户，最终，他们只是想把事情做好！</p>
<p>而且，由于一个APP一天可以启动N次，因此务必要注意该指标。 从用户点击您的APP图标到在屏幕上绘制第一个视图之间经过的所有时间都有助于您感知到APP的启动时间。</p>
<p>在讨论影响启动时间的因素之前，让我们先了解一下各种启动。</p>
<h4 id="启动类型"><a href="#启动类型" class="headerlink" title="启动类型"></a>启动类型</h4><ul>
<li>1、冷启动<br>这意味着系统内核缓冲区缓存中不存在App进程。 通常是在首次启动该APP时或在重新启动设备并清除内核缓存时发生的。 这种启动花费了最长的时间，因此应考虑进行启动时间分析。</li>
<li>2、暖启动<br>这是一种启动类型，其中APP进程和数据存在于系统的内存中，然后被带到前台。 这类似于杀死该APP并重新启动。</li>
<li>3、热启动<br>当APP从后台或挂起状态进入前台时，就会发生这种启动。</li>
</ul>
<p>现在，我们知道了启动类型，我们需要讨论两种启动时间。</p>
<h4 id="main-之前的启动-时间"><a href="#main-之前的启动-时间" class="headerlink" title="main()之前的启动 时间"></a>main()之前的启动 时间</h4><p>这是内核用于加载APP（<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">Mach-O可执行文件</a>）的时间。 您可以在此处阅读有关<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">加载顺序</a>的更多信息。</p>
<blockquote>
<p>如果您是Objective-C开发人员，则可能已经看过APP的main（），但是即使您使用Swift编写代码，该方法仍然存在，但看不到它。</p>
</blockquote>
<p>直到控件到达您APP的main（）函数为止的所有时间都计入主时间之前。</p>
<p>而且，由于所有这些都是在控件到达您的APP之前发生的，因此这段时间很难控制。 好吧，不是真的，但是我们将讨论这一点。</p>
<p>Dyld有一个内置的机制来衡量这一点，您所要做的就是编辑您的APP方案，并将环境变量DYLD_PRINT_STATISTICS添加为1，如下所示<br><img src="/2021/05/01/iOS-APP-Launch-Explain/DYLD_PRINT_STATISTICS.png" alt="scheme editor"><br>您还可以将构建配置设置为“发布”模式，最好在iPhone而不是模拟器上运行它。 完成配置并运行APP后，您会在控制台中看到类似的内容。<br><img src="/2021/05/01/iOS-APP-Launch-Explain/Pre_main_launch_metrics_in_console.png" alt="Pre-main launch metrics in console
"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dylib loading time: 378.82 milliseconds (52.2%)</span><br><span class="line">    rebase/binding time: 126687488.8 seconds (397295283.8%)</span><br><span class="line">        ObjC setup time: 115.89 milliseconds (15.9%)</span><br><span class="line">       initializer time: 335.12 milliseconds (46.2%)</span><br><span class="line">       slowest intializers :</span><br><span class="line">         libSystem.B.dylib :   5.33 milliseconds (0.7%)</span><br><span class="line">libMainThreadChecker.dylib : 301.22 milliseconds (41.5%)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面我们可以知道有许多因素会影响启动时间，例如dylib加载时间，rebase/binding， ObjC 设置， 初始化时间，libSystem.B.dylib，以及libMainThreadChecker.dylib等。</p>
<p>首先，我们需要研究第二种启动时间。</p>
<h4 id="main-之后的启动时间"><a href="#main-之后的启动时间" class="headerlink" title="main()之后的启动时间"></a>main()之后的启动时间</h4><p>这是从启动APP的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application">app:willFinishLaunchingWithOptions：</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application">app:didFinishLaunchingWithOptions</a>到您的AppDelegate一直到第一个ViewControllers绘图周期结束为止的时间，即直到调用viewDidLoad和viewDidLayoutSubviews为止。</p>
<p>您可能已经猜到了，要测量该时间，您必须测量从willFinishLaunching方法到第一个ViewController的viewDidLayoutSubviews（通常是APP的预排/主屏幕）之间的时间。</p>
<p>并且，我们还将讨论影响启动时间的因素。</p>
<p>因此，总启动时间的最终方程为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-main() 时间 + post-main() 时间 = App 总的启动时间</span><br></pre></td></tr></table></figure>
<h4 id="影响启动时间性能的因素"><a href="#影响启动时间性能的因素" class="headerlink" title="影响启动时间性能的因素"></a>影响启动时间性能的因素</h4><p>有几个因素会影响您的启动时间效果</p>
<h5 id="动态库加载时间"><a href="#动态库加载时间" class="headerlink" title="动态库加载时间"></a>动态库加载时间</h5><p>动态加载程序（dyld）加载APP的可执行文件，并检查可执行文件中的加载命令，以查找App所需的框架和动态库。 添加到您的APP的任何动态框架都有助于这一时期。</p>
<p>因此，限制在Xcode的“Linked Frameworks and Libraries”设置嵌入的框架数量可以帮助减少启动时间。</p>
<p>您可以在此处阅读有关<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">dyld</a>的更多信息。</p>
<p>解决此问题的另一种方法是使用静态框架，它们是在编译时内置于APP可执行文件中的，因此dylib不必完成上述所有工作。<br><img src="/2021/05/01/iOS-APP-Launch-Explain/swift_framework.png" alt="swift_framework"><br>通过这样做，您可以节省大量的pre-main（）启动时间。<br><img src="/2021/05/01/iOS-APP-Launch-Explain/static_library.png" alt="static_library"><br>尽管在iOS 13中，dyld3包含在iOSAPP中，这是一个很大的改进，因为它将使iOSAPP的启动速度提高2倍。 但是，仍然无法使用静态框架。</p>
<h5 id="Static-初始化"><a href="#Static-初始化" class="headerlink" title="Static 初始化"></a>Static 初始化</h5><p>APP中的某些代码必须在iOS运行您的APP的main（）函数之前运行，这会增加启动时间。 此代码包括</p>
<ul>
<li>C / C ++静态初始化程序-通常，您不会在APP中找到类似的东西，但是如果您愿意，我希望对它有所了解。 任何定义为__attribute__((constructor)) 的函数都是C中的静态构造函数，它们的特长是在执行main（）之前调用它们！ 你可以在<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/__attribute__constructor-__attribute__destructor-syntaxes-c/">这里</a>读更多关于它的内容。</li>
<li>在OC类或Category中声明的 <code>+load</code>方法。 如上图所示，它们在<code>main()</code>之前调用，并增加了ObjC的设置时间。 此外，不建议使用此方法，而应改用<code>+ initialize</code>方法。</li>
<li>链接到APP可执行文件或Mach-O的<code>__DATA,__mod_init_func</code>段的任何函数。 这些函数通常位于__DATA段的__mod_init_func段内。</li>
</ul>
<p>因此，根据一般经验，将代码移至APP生命周期的后期，即APP启动完成后但需要工作结果之前。</p>
<p>您可以在Xcode中使用静态初始化程序工具来查找您的APP花了多少时间来运行静态初始化程序。</p>
<h4 id="UIKit生命周期方法"><a href="#UIKit生命周期方法" class="headerlink" title="UIKit生命周期方法"></a>UIKit生命周期方法</h4><p>UIKit初始化您的APP委托类的实例，并向其发送<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application"><code>application（_：willFinishLaunchingWithOptions :)</code></a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application"><code>application（_：didFinishLaunchingWithOptions :)</code></a>消息。</p>
<p>这些方法在主线程上被调用，由于执行它们所花费的时间计入启动时间，因此建议仅在此处创建APP的初始显示并推迟其他任务。</p>
<p>如果有必要向用户显示之前数据，请推迟数据模型同步或API调用，直到APP运行为止。 在首次使用而不是在APP启动时初始化非视图功能，例如持久性存储和位置服务。</p>
<h4 id="初始视图层次结构"><a href="#初始视图层次结构" class="headerlink" title="初始视图层次结构"></a>初始视图层次结构</h4><p>在APP的第一帧上绘制视图所需的时间也计入启动时间。 在UIKit中，每个视图都添加到主线程上的视图层次结构中，因此，更复杂的视图层次结构会导致启动时间增加。</p>
<p>降低视图层次结构的复杂性，并用常规UIView替换覆盖<code>draw</code>方法的视图将有助于缩短加载时间。</p>
<p>尝试仅渲染屏幕上可见的视图部分。</p>
<p>可能还有很多其他原因可能会影响启动时间，但是我可以找到这些主要原因，并且，我相信，如果您认真地遵循上述方法，将会为用户创造更好的体验。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>1、有三种类型的启动类型， 冷启动，暖启动和热启动。</li>
<li>2、启动时间分为两类：<br>main之前—<code> main()</code>执行之前花费的时间<br>main之后—在<code>main()</code>执行之后直到第一个ViewController可见所花费的时间。</li>
<li>3、我们研究了导致启动时间增加的几个因素：动态库加载时间，静态初始化程序，执行AppDelegate生命周期方法所花费的时间以及绘制第一个ViewController所花费的时间。</li>
<li>4、我们发现您应该<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">阅读本文</a>，以了解有关<code>pre-main()</code>流程的更多信息。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/406/">App Startup Time</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/423/">Optimizing App Launch</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time">Reduce App Launch Time</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/04/30/记录使用hexo-发布出错/"><span>记录使用hexo 发布出错</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/04/30/记录使用hexo-发布出错/" rel="bookmark">
        <time class="entry-date published" datetime="2021-04-30T14:07:41.000Z">
          2021-04-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>使用hexo d来推文章到github上，一直报错，尝试了很多次切换https链接发布和ssh发布都不行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Permission to someone.github.io.git denied to deploy key</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (/Users/rick/Documents/Blog/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:209:13)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure>
<p>方向错了，因为deploy失败所以潜意识一直认为是ssh的问题，执行了ssh添加id_rsa</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_swift_rsa</span><br></pre></td></tr></table></figure>
<p>最后查询到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">ssh-add -K ~/.ssh/id_swift_rsa</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>通过终端执行上面的指令后，终于发布成功了。</p>
<h3 id="使用本地图显示异常"><a href="#使用本地图显示异常" class="headerlink" title="使用本地图显示异常"></a>使用本地图显示异常</h3><p>通过install hexo-asset-image这个库来显示本地图，但是发现还是无法展示，需要更改_config.yml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://rickli.github.io/</span><br><span class="line">root: /</span><br><span class="line"></span><br><span class="line">post_asset_folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在md需要插入图片的地方使用</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">event_respond_type</span>](<span class="link">iOS-Respond-Chain-Explain/event_respond_type.png</span>)</span><br></pre></td></tr></table></figure>
<p>Done！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/杂记/">杂记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/04/27/iOS-Respond-Chain-Explain/"><span>iOS 响应链详解</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/04/27/iOS-Respond-Chain-Explain/" rel="bookmark">
        <time class="entry-date published" datetime="2021-04-27T03:10:27.000Z">
          2021-04-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="iOS-响应链机制"><a href="#iOS-响应链机制" class="headerlink" title="iOS 响应链机制"></a>iOS 响应链机制</h3><p>这篇文章是为了彻底搞清楚iOS响应链而写的。<br>在iOS事件中分三部分：</p>
<ul>
<li><p>触摸事件</p>
</li>
<li><p>远程控制事件</p>
</li>
<li><p>加速计事件<br><img src="/2021/04/27/iOS-Respond-Chain-Explain/event_respond_type.png" alt="event_respond_type"></p>
<blockquote>
<p>三种事件<br>我们暂时先只关注触摸事件。</p>
</blockquote>
<h4 id="响应链对象"><a href="#响应链对象" class="headerlink" title="响应链对象"></a>响应链对象</h4><p>学习触摸事件首先要了解一个比较重要的概念-响应者对象（UIResponder）<br>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。以下都是继承自UIResponder的，所以都能接收并处理事件。</p>
</li>
<li><p>UIApplication</p>
</li>
<li><p>UIViewController</p>
</li>
<li><p>UIView<br>那么为什么继承自UIResponder的类就能够接收并处理事件呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></li>
</ul>
<p>因为UIResponder中提供了以下4个对象方法来处理触摸事件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIResponder内部提供了以下方法来处理事件触摸事件</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">//加速计事件</span></span><br><span class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">//远程控制事件</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></span><br><span class="line"><span class="comment">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 一根或者多根手指离开view，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 提示：touches中存放的都是UITouch对象</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是：以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。</p>
<ul>
<li><p>如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p>
</li>
<li><p>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象<br>重写以上四个方法，如果是处理UIView的触摸事件。必须要自定义UIView子类继承自UIView。因为苹果不开源，没有把UIView的.m文件提 供给我们。我们只能通过子类继承父类，重写子类方法的方式处理UIView的触摸事件（注意：我说的是UIView触摸事件而不是说的 UIViewController的触摸事件）。<br>如果是处理UIViewController的触摸事件，那么在控制器的.m文件中直接重写那四个方法即可！</p>
<h4 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h4><p>对于触摸事件，首先要找到能够响应该事件的对象，iOS是用hit_testing来找到哪个视图被触摸了，也就是以keyWindow为起点，hit-test view为终点，逐级调用hitTest:withEvent<br><img src="/2021/04/27/iOS-Respond-Chain-Explain/response_chain.png" alt="response_chain"></p>
</li>
<li><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是FIFO，即先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。</p>
</li>
<li><p>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</p>
</li>
<li><p>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<br>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。<br>所以点击事件的响应是，顶部的view 传到父view，一直到父类上面<br>hitTest:withEvent方法的处理流程：</p>
</li>
</ul>
<p>先调用pointInside:withEvent:判断触摸点是否在当前视图内。</p>
<p>– 如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高(top–&gt;bottom)依次调用。</p>
<p>– 如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略（表示根本不可能在该视图内）。<br>  ●如果某视图的pointInside:withEvent:返回YES，并且它的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己self。</p>
<p>  ●如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent也返回这个对象，也就是沿原路回退，最终将hit-test view传递给keyWindow进行响应。</p>
<p> <br>  ●以下视图的hitTest-withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：</p>
<ul>
<li><p>隐藏（hidden=YES）的视图；</p>
</li>
<li><p>禁止用户操作（userInteractionEnabled = NO）的视图；</p>
</li>
<li><p>alpha&lt;0.01的视图；</p>
</li>
<li><p>视图超出父视图的区域；<br>既然系统通过hitTest:withEvent:做传递链取回hit-test view，那么我们可以在其中一环修改传递回的对象，从而改变正常的事件响应链。</p>
</li>
</ul>
<p>对于一个View，hitTest为什么会调用两次？</p>
<p>因为一次是消息传递时，还有一次是响应时。分别是入栈出栈操作，父View先入栈，后出栈。</p>
<p>不管视图能不能处理事件，只要点击了视图就会产生事件，关键看该事件是由谁来处理。也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已。</p>
<p>技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件（我下面会实现该案例），或者重写自己的hitTest:withEvent:方法return self. 但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view。</p>
<p>return nil的含义：</p>
<p>hitTest:withEvent:中return nil的意思是调用当前的hitTest:withEvent:方法的view不是合适的view，子控件也不是合适的view。如果同级的兄弟控件也没有合适的view，那么最合适的view就是父控件。</p>
<p><code>objc[self.view convertPoint:point fromView:self]</code> </p>
<p>把self.view的坐标系从self转换到自己的坐标系。然后就可以通过手动调用pointInside来判断是否在某个view内。</p>
<h4 id="重写父视图来对子视图控制响应事件是我们推荐的方式"><a href="#重写父视图来对子视图控制响应事件是我们推荐的方式" class="headerlink" title="重写父视图来对子视图控制响应事件是我们推荐的方式"></a>重写父视图来对子视图控制响应事件是我们推荐的方式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RewriteSuperView</span> : <span class="title">UIView</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *bottom;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;RewriteSuperView.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RewriteSuperView</span></span></span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;tag=====%ld&quot;</span>,<span class="keyword">self</span>.tag);</span><br><span class="line">    <span class="built_in">CGPoint</span> bottomPoint = [<span class="keyword">self</span>.bottom convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.bottom pointInside:bottomPoint withEvent:event])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这几行代码的意思是：检测点击区域是否是在bottom区域，如果是，则直接使用bottom响应点击，否则调用父类的hitTest,按正常的传递响应。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>总结一句：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（子控件到父控件）。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a><a href="/tags/UI/">UI</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Rick Li
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>