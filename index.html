<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Coding</title>

  
  <meta name="author" content="Rick Li">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Coding"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Coding" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Coding</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/02/Safe-Thread/"><span>关于线程安全</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/Safe-Thread/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T11:00:34.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>线程安全可变字典的简单实现。 在大多数情况下，您需要使用NSCache，但是在需要手动控制内存不足的情况下从缓存中清除的内容时，它很有用。<strong>警告：</strong>我仅将其用于设置/获取密钥。 枚举在这里不是线程安全的，并且仍然会引发异常…</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dictionary-Subclasss whose primitive operations are thread safe.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JPThreadSafeMutableDictionary</span> : <span class="title">NSMutableDictionary</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;JPThreadSafeMutableDictionary.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKED(...) OSSpinLockLock(&amp;_lock); \</span></span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">OSSpinLockUnlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPThreadSafeMutableDictionary</span> </span>&#123;</span><br><span class="line">    OSSpinLock _lock;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *_dictionary; <span class="comment">// Class Cluster!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSObject</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCapacity:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithObjects:(<span class="built_in">NSArray</span> *)objects forKeys:(<span class="built_in">NSArray</span> *)keys &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">self</span> initWithCapacity:objects.count])) &#123;</span><br><span class="line">        [objects enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            _dictionary[keys[idx]] = obj;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithCapacity:(<span class="built_in">NSUInteger</span>)capacity &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _dictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:capacity];</span><br><span class="line">        _lock = OS_SPINLOCK_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSMutableDictionary</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey &#123;</span><br><span class="line">    LOCKED(_dictionary[aKey] = anObject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addEntriesFromDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary &#123;</span><br><span class="line">    LOCKED([_dictionary addEntriesFromDictionary:otherDictionary]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDictionary:(<span class="built_in">NSDictionary</span> *)otherDictionary &#123;</span><br><span class="line">    LOCKED([_dictionary setDictionary:otherDictionary]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)aKey &#123;</span><br><span class="line">    LOCKED([_dictionary removeObjectForKey:aKey])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    LOCKED([_dictionary removeAllObjects]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSUInteger</span> count = _dictionary.count)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)allKeys &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSArray</span> *allKeys = _dictionary.allKeys)</span><br><span class="line">    <span class="keyword">return</span> allKeys;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)allValues &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSArray</span> *allValues = _dictionary.allValues)</span><br><span class="line">    <span class="keyword">return</span> allValues;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)aKey &#123;</span><br><span class="line">    LOCKED(<span class="keyword">id</span> obj = _dictionary[aKey])</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)keyEnumerator &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSEnumerator</span> *keyEnumerator = [_dictionary keyEnumerator])</span><br><span class="line">    <span class="keyword">return</span> keyEnumerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mutableCopyWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line">    LOCKED(<span class="keyword">id</span> copiedDictionary = [[<span class="keyword">self</span>.class allocWithZone:zone] initWithDictionary:_dictionary])</span><br><span class="line">    <span class="keyword">return</span> copiedDictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">                                  objects:(<span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> [])stackbuf</span><br><span class="line">                                    count:(<span class="built_in">NSUInteger</span>)len &#123;</span><br><span class="line">    LOCKED(<span class="built_in">NSUInteger</span> count = [[_dictionary <span class="keyword">copy</span>] countByEnumeratingWithState:state objects:stackbuf count:len]);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performLockedWithDictionary:(<span class="keyword">void</span> (^)(<span class="built_in">NSDictionary</span> *dictionary))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (block) LOCKED(block(_dictionary));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:JPThreadSafeMutableDictionary.class]) &#123;</span><br><span class="line">        JPThreadSafeMutableDictionary *other = object;</span><br><span class="line">        __block <span class="built_in">BOOL</span> isEqual = <span class="literal">NO</span>;</span><br><span class="line">        [other performLockedWithDictionary:^(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">            [<span class="keyword">self</span> performLockedWithDictionary:^(<span class="built_in">NSDictionary</span> *otherDictionary) &#123;</span><br><span class="line">                isEqual = [dictionary isEqual:otherDictionary];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> isEqual;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>LOCKED扩展为三个语句，而if仅保护第一个语句。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKED(...) do &#123; \</span></span><br><span class="line">OSSpinLockLock(&amp;_lock); \</span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">OSSpinLockUnlock(&amp;_lock); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">NO</span>)</span><br></pre></td></tr></table></figure>
<p>找到一个解决方案，给定countByEnumeratingWithState：在枚举开始之前被调用一次，在枚举结束之后被调用一次（上帝赐予。我们有“适当的时间”指示器）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">                                  objects:(<span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> [])stackbuf</span><br><span class="line">                                    count:(<span class="built_in">NSUInteger</span>)len &#123;</span><br><span class="line">    OSSpinLockLock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *enumerationDict = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;stackbuf);</span><br><span class="line">    <span class="keyword">if</span> (!enumerationDict) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;stackbuf, (enumerationDict = _dictionary.copy), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [enumerationDict countByEnumeratingWithState:state objects:stackbuf count:len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;stackbuf, <span class="literal">nil</span>, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSpinLockUnlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果实现isEqual，则还必须实现-(int)hash方法（并且可能使用LOCK()宏返回[super hash]值）。</p>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>NSOperation是一个类，允许您以结构化方式对异步操作进行建模。 它为应用程序的高级部分提供了一种启动异步操作的方式，而不必担心它们如何执行的细节。  NSOperation可以在线程上运行，也可以通过运行循环回调或其他更特殊的方式异步运行。 重要的是您的应用程序的高级代码无关紧要。 它只是开始操作，并在操作完成时得到通知。</p>
<blockquote>
<p>重要提示：NSOperation通常用于在线程上运行CPU密集型代码，但不仅仅是线程。  NSOperation可用于对任何异步操作进行建模。 例如，示例代码“ LinkedImageFetcher”显示了如何使用NSOperation进行网络操作。</p>
</blockquote>
<p>NSOperation鼓励使用一种称为线程限制的编程模型。 在此模型中，线程使用的资源由​​该线程拥有，而不在线程之间共享。 这是一种编写线程代码的好方法，而不会涉及上一节中讨论的各种问题。 使用NSOperation的一种好方法是：</p>
<ul>
<li>使用完成工作所需的数据的不变副本来初始化操作。</li>
<li>执行操作； 在执行过程中，它仅对初始化时使用的数据以及它自己创建的数据进行操作，并且不与其他线程共享。</li>
<li>操作完成后，它将结果提供给应用程序的其余部分，此时，操作本身不再触及这些结果。</li>
</ul>
<p>使用单独的NSOperation对象解决了通用线程代码的许多问题：</p>
<ul>
<li>您可以将与操作相关的辅助数据存储为NSOperation对象的属性，</li>
<li>您可以使用这些属性，甚至NSOperation对象本身，作为标记来确定操作结果是否过时</li>
<li>NSOperation对象是您用来处理的句柄 可以取消该操作</li>
<li>您可以保证所有线程化代码都在该操作中运行，从而避免重新分配问题</li>
</ul>
<p>NSOperation还具有许多其他有用的功能：</p>
<ul>
<li>每个操作都由一个操作队列（NSOperationQueue）执行。 </li>
<li>每个队列都有一个并行执行的最大操作数（maxConcurrentOperationCount），通常称为队列宽度。 该宽度默认为适合您正在运行的设备的值，但是您可以将其设置为适合手头任务的值。 例如，可以通过将队列宽度设置为1来保证操作被序列化（一次执行一次）。或者，如果您的操作进入网络，则可以使用队列宽度来限制并发网络操作的数量。</li>
<li>您可以创建操作队列以对问题空间进行建模。 例如，文件复制程序可以在每个磁盘上使用一个操作队列，以避免损坏磁盘头。</li>
<li>您可以使操作依赖于其他操作，从而建立操作执行和操作扇入的链。<br>重要的是要意识到NSOperation和NSOperationQueue不会做您自己做不到的任何事情。 如果确实需要，可以使用自己的代码复制所有此结构。 但是，如果您没有用于管理异步代码的现有结构，并且不希望重新实现轮子，那么NSOperation非常适合您。</li>
</ul>
<p>使用NSOperation实现异步重新计算的第一步是创建一个NSOperation的子类来进行计算。 您应该特别注意操作的接口，如其头文件中所述。 最重要的是，该接口中的所有内容都应具有定义明确的线程安全性策略。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdderOperation</span> : <span class="title">NSOperation</span>  </span></span><br><span class="line">- (<span class="keyword">id</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;  <span class="comment">// only meaningful after the operation is finished  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readonly</span> ) <span class="built_in">NSString</span> * formattedTotal;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>该操作的初始化方法（在此示例中为-initWithNumbers :）应将运行该操作必不可少的所有信息作为参数。 在这种情况下，只需要添加数字列表即可。<br>此最小接口中的唯一其他项是客户端可用来获取操作结果的属性。 在这种情况下，formattedTotal属性是要在列表视图的总值中显示的字符串。</p>
<p>一个操作从NSOperation继承了各种重要的属性。 最关键的是isFinished属性。 客户端可以观察该属性（从键值观察（KVO）的角度），以确定何时完成该操作。 或者，如果您不是KVO的忠实拥护者，则可以使用其他机制进行操作，以表示已完成。 例如，您的操作可能会在完成后发布通知（使用NSNotificationCenter），或者它可能定义委托协议。</p>
<blockquote>
<p>警告：不管您的操作如何发出完成信号，您的客户端都必须知道发出该信号的线程。 此问题将在下面更详细地讨论。</p>
</blockquote>
<p>还有另一件事要注意：formattedTotal属性是原子的。 这是因为很可能同时从多个线程访问此属性，并且该属性必须是原子的，以确保安全。 通常，操作的所有公共属性都应该是原子的。</p>
<p>给定头文件，该操作必须包括以下内容的实现：</p>
<ul>
<li>initWithNumbers：方法-这有些微妙，下面将详细讨论。</li>
<li>formattedTotal属性-可以合成此属性。</li>
<li>dealloc方法—这里没有什么大的惊喜； 唯一的问题是该方法可以由任何线程执行。</li>
<li>main方法—这是您的操作进行计算的地方，下面将对其进行详细讨论<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers</span><br><span class="line">&#123;</span><br><span class="line">    assert(numbers != <span class="literal">nil</span>);</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>-&gt;_numbers = [numbers <span class="keyword">copy</span>];</span><br><span class="line">        assert(<span class="keyword">self</span>-&gt;_numbers != <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里有两点需要注意：</li>
<li>该方法创建传入numbers数组的不可变副本。 这样可以防止前面讨论的问题，在该问题上，主线程可能会使数组发生变化，而运行该操作的辅助线程正在处理该数组。</li>
<li>由您决定是否使初始化方法线程安全。 因为您控制操作的分配，所以可以保证将在主线程（或其他特定的辅助线程）上调用该操作。 但是，如果使初始化方法线程安全相对容易，则应这样做。</li>
</ul>
<p>该操作的-main方法进行实际计算。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span>      numberCount;</span><br><span class="line">    <span class="built_in">NSUInteger</span>      numberIndex;</span><br><span class="line">    <span class="built_in">NSInteger</span>       total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is called by a thread that&#x27;s set up for us by the NSOperationQueue.</span></span><br><span class="line"></span><br><span class="line">    assert( ! [<span class="built_in">NSThread</span> isMainThread] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the heavy lifting (-:</span></span><br><span class="line"></span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    numberCount = [<span class="keyword">self</span>.numbers count];</span><br><span class="line">    <span class="keyword">for</span> (numberIndex = <span class="number">0</span>; numberIndex &lt; numberCount; numberIndex++) &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *  numberObj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for cancellation.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sleep for a second. This makes it easiest to test cancellation </span></span><br><span class="line">        <span class="comment">// and so on.</span></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the mathematics.</span></span><br><span class="line"></span><br><span class="line">        numberObj = [<span class="keyword">self</span>.numbers objectAtIndex:numberIndex];</span><br><span class="line">        assert([numberObj isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]);</span><br><span class="line"></span><br><span class="line">        total += [numberObj integerValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set our output properties base on the value we calculated. Our client </span></span><br><span class="line">    <span class="comment">// shouldn&#x27;t look at these until -isFinished goes to YES (which happens when </span></span><br><span class="line">    <span class="comment">// we return from this method).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.formattedTotal = [<span class="keyword">self</span>.formatter stringFromNumber:[<span class="built_in">NSNumber</span> numberWithInteger:total]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键点包括：</p>
<ul>
<li>此方法应在辅助线程上运行。 它涉及的所有内容都必须具有某种线程安全性策略。 在此示例中：Numbers属性是线程安全的，因为只能通过-initWithNumbers：方法对其进行更改，该方法在运行此代码之前必须已完成。<br>numberCount，numberIndex，total和numberObj变量是安全的，因为它们是局部变量，因此不会在线程之间共享。<br>formattedTotal属性是安全的，因为在操作完成之前，客户端不应该查看它。 即使客户端忽略此要求，由于该属性是原子的，他们的访问也将是安全的：客户端将获得原始值（即nil）或正确值，而不会得到任何奇怪的杂烩。<br>该操作通过在其主计算循环中调用isCancelled来测试是否取消。<blockquote>
<p>重要提示：虽然并非严格要求标准操作检查取消，但强烈建议您执行此操作。 如果某个操作没有定期检查取消，则会浪费不再需要的资源计算结果。</p>
</blockquote>
</li>
</ul>
<p>在并发操作中支持取消操作比较棘手。 如果要创建并发操作，请参阅“并发操作”以获取有关如何正确执行此操作的信息。</p>
<p>一旦执行了可以执行任务的操作，就必须在应用程序中使用它。 第一步是创建一个NSOperationQueue，以在其上运行操​​作。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ListAdderViewController</span> () [...]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readonly</span> ) <span class="built_in">NSOperationQueue</span> * queue;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readwrite</span>) AdderOperation *   inProgressAdder;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ListAdderViewController</span></span></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:<span class="built_in">UITableViewStyleGrouped</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [...] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>-&gt;_queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">        assert(<span class="keyword">self</span>-&gt;_queue != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">        [...] </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>警告：如果可以重新分配视图控制器，则将操作队列托管在视图控制器中是很棘手的。 因为ListAdderViewController是根视图控制器，因此无法被释放。 如果您的视图控制器可能被释放，则必须采取措施避免其-dealloc方法在辅助线程上运行。 有关详细信息，请参见“分配问题”。</p>
</blockquote>
<p>一旦有了操作队列，就可以通过简单地将操作添加到队列中来开始操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recalculateTotalUsingOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re already calculating, cancel that operation.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.inProgressAdder != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.inProgressAdder cancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start up a replacement operation.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.inProgressAdder = [[[AdderOperation alloc] initWithNumbers:<span class="keyword">self</span>.numbers] autorelease];</span><br><span class="line">    assert(<span class="keyword">self</span>.inProgressAdder != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.inProgressAdder addObserver:<span class="keyword">self</span> </span><br><span class="line">        forKeyPath:<span class="string">@&quot;isFinished&quot;</span> </span><br><span class="line">        options:<span class="number">0</span> </span><br><span class="line">        context:&amp;<span class="keyword">self</span>-&gt;_formattedTotal</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.queue addOperation:<span class="keyword">self</span>.inProgressAdder];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The user interface is adjusted by a KVO observer on recalculating.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.recalculating = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两点需要注意：代码跟踪inProgressAdder属性中最近排队的操作。 当开始新操作时，它将用刚刚开始的操作替换该值。 这有两个好处：开始操作时，可以取消上一个操作。 这意味着新操作不仅会持续执行，还会消耗宝贵的CPU周期，电池寿命和内存。<br>操作完成后，可以确定操作结果是否仍然有意义。 在下面的更多内容。<br>在对操作进行排队之前，它将添加对isFinished属性的观察。 这样就可以确定操作何时完成。<br>最后，当操作完成时，您必须检查并提交结果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath </span><br><span class="line">    ofObject:(<span class="keyword">id</span>)object </span><br><span class="line">    change:(<span class="built_in">NSDictionary</span> *)change </span><br><span class="line">    context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == &amp;<span class="keyword">self</span>-&gt;_formattedTotal) &#123;</span><br><span class="line">        AdderOperation *    op;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the operation has finished, call -adderOperationDone: on the main thread to deal </span></span><br><span class="line">        <span class="comment">// with the results.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// can be running on any thread</span></span><br><span class="line">        assert([keyPath isEqual:<span class="string">@&quot;isFinished&quot;</span>]);</span><br><span class="line">        op = (AdderOperation *) object;</span><br><span class="line">        assert([op isKindOfClass:[AdderOperation <span class="keyword">class</span>]]);</span><br><span class="line">        assert([op isFinished]);</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(adderOperationDone:)</span><br><span class="line">            withObject:op </span><br><span class="line">            waitUntilDone:<span class="literal">NO</span></span><br><span class="line">        ];</span><br><span class="line">    &#125; [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)adderOperationDone:(AdderOperation *)op</span><br><span class="line">&#123;</span><br><span class="line">    assert([<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line"></span><br><span class="line">    assert(<span class="keyword">self</span>.recalculating);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always remove our observer, regardless of whether we care about </span></span><br><span class="line">    <span class="comment">// the results of this operation.</span></span><br><span class="line"></span><br><span class="line">    [op removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;isFinished&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see whether these are the results we&#x27;re looking for. </span></span><br><span class="line">    <span class="comment">// If not, we just discard the results; later on we&#x27;ll be notified </span></span><br><span class="line">    <span class="comment">// of the latest add operation completing.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="keyword">self</span>.inProgressAdder) &#123;</span><br><span class="line">        assert( ! [op isCancelled] );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the value to our model.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.formattedTotal = op.formattedTotal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear out our record of the operation. The user interface is adjusted </span></span><br><span class="line">        <span class="comment">// by a KVO observer on recalculating.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.inProgressAdder = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.recalculating = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此过程分为两部分。 首先，当操作的isFinished属性更改时，KVO调用-observeValueForKeyPath：ofObject：change：context：方法。 此方法与更改isFinished属性的代码在同一线程上运行，在这种情况下，这意味着它在辅助线程上运行。 它无法从辅助线程操纵用户界面，因此它通过使用-performSelectorOnMainThread：withObject：waitUntilDone：调用-adderOperationDone：方法来将工作推迟到主线程。</p>
<p>-adderOperationDone：方法执行三件事：</p>
<ul>
<li>删除对isFinished属性的观察。 </li>
<li>它通过将已完成的操作（op）与最近启动的操作（inProgressAdder）进行比较，以查看该操作的结果是否仍然有意义。 如果这些不匹配，则操作的结果无关紧要，并被丢弃。</li>
<li>如果操作的结果仍然有意义，则将它们提交给用户界面。</li>
</ul>
<p>整个过程的一个不明显的方面是inProgressAdder属性仅由主线程访问。 这意味着它不必一定是原子的，但更重要的是，它不需要任何并发控制。 如果没有这种隐式序列化，</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="keyword">self</span>.inProgressAdder) &#123;     [... <span class="keyword">do</span> something with inProgressAdder ...]     <span class="keyword">self</span>.inProgressAdder = <span class="literal">nil</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>这总结了使用NSOperation异步运行长时间运行的计算的基本过程。 下一节将超越前面显示的最小实现，并涵盖一些更现实的情况。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdderOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line">&#123;</span><br><span class="line">    [... instance variables elided ...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithNumbers:(<span class="built_in">NSArray</span> *)numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up by the init method that can&#x27;t be changed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readonly</span> ) <span class="built_in">NSArray</span> *         numbers;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readonly</span> ) <span class="built_in">NSUInteger</span>        sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// must be configured before the operation is started</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSTimeInterval</span>    interNumberDelay;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only meaningful after the operation is finished</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readonly</span> ) <span class="built_in">NSInteger</span>         total;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readonly</span> ) <span class="built_in">NSString</span> *        formattedTotal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>而且，此接口通过在类扩展中声明的一堆内部属性进行了扩展。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AdderOperation</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// only accessed by the operation thread</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">retain</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSNumberFormatter</span> *   formatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read/write versions of public properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSInteger</span>             total;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *            formattedTotal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在这些接口中声明的每个属性都有一个定义明确的线程安全性策略。 这些策略包括：</p>
<ul>
<li>不变性-一些属性是在初始化时设置的，此后不修改。 数字数组就是一个很好的例子。</li>
<li>仅配置时间-可以在创建操作的点与开始操作的点之间安全地设置某些属性，例如interNumberDelay。 在那之后，修改此类属性既不安全，也无效。</li>
<li>线程限制-某些属性是线程安全的，因为只有运行该操作的线程才能访问这些属性。 格式化程序属性是此技术的一个示例。</li>
<li>串行线程限制-某些属性（例如total和formattedTotal）最初仅由操作使用，然后在操作完成时可用于其他代码。</li>
</ul>
<p>重要说明：在实施线程代码时，对于您从线程代码接触的每条数据制定线程安全策略至关重要。  NSOperation使开发此类策略变得更加容易。</p>
<h3 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h3><p>重要的是要认识到AdderOperation格式化程序属性是线程限制的一个人为的示例。 </p>
<p>在实际的应用程序中，线程限制是一种更为强大的技术。 具有异步解析XML的操作。 在此操作中，有一个NSXMLParser对象，在该对象中有一个libxml2 XML解析器对象。 可以从任意线程调用这些对象，但是一次只能从一个线程调用它们。 线程限制使从线程代码中安全地使用此类对象成为可能，而NSOperation是实现线程限制的好方法。</p>
<h2 id="NSOperations提示和技巧"><a href="#NSOperations提示和技巧" class="headerlink" title="NSOperations提示和技巧"></a>NSOperations提示和技巧</h2><p>本节包含一些使用NSOperation的常规提示和技巧。</p>
<h3 id="NSOperation和GCD"><a href="#NSOperation和GCD" class="headerlink" title="NSOperation和GCD"></a>NSOperation和GCD</h3><p>在iOS 4中引入的Grand Central Dispatch（GCD）与NSOperation的关系还不是很明显。 简短的答案是，这两种技术可以很好地互补。  GCD是一种低级API，可让您灵活地以各种不同的方式来构造代码。 相反，NSOperation为您提供了可用于异步代码的默认结构。 如果您正在寻找现有的，定义明确的，非常适合Cocoa应用程序的结构，请使用NSOperation。 如果您要创建自己的结构以完全匹配您的问题空间，请使用GCD。</p>
<h3 id="解除分配问题"><a href="#解除分配问题" class="headerlink" title="解除分配问题"></a>解除分配问题</h3><p>使用UIKit对象中的辅助线程（例如视图控制器）的最大问题之一是确保安全地释放对象。 本节说明了此问题的产生方式以及您可以采取的措施。<br>启动辅助线程时，该线程通常保留目标对象。 这种情况在很多情况下都会发生，包括：</p>
<ul>
<li>当您使用以下任何一种方法启动辅助线程时：<ul>
<li>-performSelectorInBackground：withObject：</li>
<li>-performSelector：onThread：withObject：waitUntilDone：</li>
<li>-performSelector：onThread：withObject：waitUntilDone：modes：</li>
</ul>
</li>
<li>当您使用NSThread启动辅助线程时 当您异步运行一个块并且该块引用了self或一个实例变量时</li>
<li> 当异步运行一个块并且该块引用了self或实例变量时，带有NSThread的辅助线程</li>
</ul>
<p>当辅助线程保留目标对象时，您必须确保在主线程释放其对该对象的最后一个引用之前，该线程释放该引用。 如果不这样做，则辅助线程将释放对对象的最后一个引用，这意味着对象的-dealloc方法在该辅助线程上运行。 如果对象的-dealloc方法在二级线程上执行不安全的操作，这是有问题的，这对于UIKit对象（如视图控制器）是常见的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)buttonAction:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused(sender)</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(recalculate) withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recalculate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> ( ! <span class="keyword">self</span>.cancelled ) &#123;</span><br><span class="line">        [... calculate ...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">    <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">// race starts here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-viewWillDisappear：取消方法集以停止辅助线程执行其计算。 这开始在正在忙于拆除视图控制器的主线程与注意到已设置并实际上已退出的canceled属性的辅助线程之间进行竞争。 在大多数情况下，辅助线程将赢得比赛，首先释放其引用，一切都会正常。 但是，如果主线程赢得比赛，并在辅助线程之前释放其引用，则辅助线程的释放将是最后一个释放，并且视图控制器的-dealloc方法将在辅助线程上运行。<br>您可能会想通过轮询辅助线程的isFinished属性来解决此问题，以确保它在从-viewWillDisappear：返回之前完成。 但是，由于NSThread中的实现细节含糊不清，因此不能保证可以解决此问题。<br>当您使用键值观察（KVO）来观察NSOperation的isFinished属性时，可能会出现类似的问题。 尽管KVO既不保留观察者也不保留被观察者，但即使您在-viewWillDisappear：方法中删除了观察者，仍然有可能，一个KVO通知可能已经在为您的对象运行。 如果发生这种情况，运行通知的线程可能最终会调用一个释放对象！<br>在一般情况下解决此问题非常棘手。 但是，如果您限制使用NSOperation，则有两种相对简单的解决方案路径：在持久对象中进行所有键值的观察，一个永不释放的对象</p>
<h2 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h2><p>NSOperation支持两种类型的操作：标准操作-这些操作（也称为非并发操作）要求NSOperationQueue代表它们提供并发性。  NSOperationQueue组织在线程上运行此类操作。<br>并发操作-这些操作带来自己的并发性。  NSOperationQueue不必专用于运行此类操作的线程。<br>当基础设施同步时，标准操作是异步运行任务的好方法。 它们通常用于长时间运行的计算，但对于快速，可靠的I / O（如磁盘I / O）也很有用。<br> 相反，当基础设施是异步的时，并发操作非常好-毫无用处地捆绑线程以等待异步API完成。 并发操作的一个很好的例子是使用NSURLConnection API执行HTTP请求的操作。<br> 正确实现并发操作有些棘手<br>重要说明：NSOperation的优点在于，它允许您抽象地对异步操作进行建模，而无需考虑基础实现技术。 您的高级代码只是开始操作并等待它完成。 不管操作实际上是如何完成工作的。 例如：</p>
<ul>
<li>该操作可能在线程上运行</li>
<li>该操作可能异步运行，由于某些基于运行循环的API而引起</li>
<li>该操作可能异步地运行，由于某些基于GCD的API而引起</li>
<li>该操作可能在单独的进程中运行</li>
</ul>
<p>此外，该操作可以更改其运行方式，而无需更改高级代码。 如果想更改以调用Web服务执行添加将非常容易。 只需要更改AdderOperation即可； 高级代码将完全相同。</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>一些执行不当的操作会在实际完成之前触发isFinished的KVO通知。 如果使用KVO来确定操作是否完成，则最好获取isFinished属性并在继续操作之前确认操作已完成，即使只是在调试时声明中也是如此。 </p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/02/Value-Reference-Pass/"><span>按值传递与按引用传递</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/Value-Reference-Pass/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T04:03:10.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>使用命令式编程语言（例如C）编写的计算机程序（如果使用C ++时不使用面向对象的样式，也可以使用C ++）广泛使用函数调用。 </p>
<p>更准确地说，它们具有“标准”入口点函数（即<code>main()</code>），该函数封装了程序的整个逻辑（即计算流程）。 </p>
<p>整个计算流程可以依次组织为几个孤立的“最小单元”，这些单元负责通过专用功能完成更轻松的任务。 </p>
<blockquote>
<p>另外，该模式可以在每个专用功能内复制，从而生成功能的嵌套链。</p>
</blockquote>
<p>实现函数调用的一个关键方面是将参数从调用方传递给被调用方的方式。</p>
<p>在本文中，我将探讨将参数传递给函数的两种最著名的方法：按值传递和按引用传递。<br>实际上，在谈论“按值传递”和“按引用传递”时，有一些棘手的问题需要清楚地理解。</p>
<ul>
<li> 按值传递: 简而言之，将参数按值传递给函数意味着该函数将拥有其自己的参数副本，即将参数的值从调用方复制到被调用方。 事实证明，修改该副本不会修改原始参数。</li>
<li>按引用传递：相反，当通过引用传递时，函数内部的参数引用的是传入的同一对象。事实证明，从函数内部对该对象进行的任何更改也将在外部看到。</li>
</ul>
<p> 不幸的是，有两种使用短语“按价值传递”和“按引用传递”的方式，它们引起潜在的混乱。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p> 从技术上讲，在C语言中，所有事物都是按值传递的。 也就是说，无论您将什么作为函数的参数，它将被复制到该函数的作用域中。 例如，用<code>foo(x)</code>调用<code>void foo(int)</code>函数会将x的值复制为foo的参数。<br>让我们用一个交换两个变量内容的函数的著名示例更好地解释一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before swapping (m,n) evaluate to: (%d,%d)\n&quot;</span>,m,n);</span><br><span class="line">    swap(m,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After swapping (m,n) evaluate to: (%d,%d)\n&quot;</span>,m,n); <span class="comment">// m and n still equal to their original values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，两个参数m，n从main方法m“复制”到函数swap的作用域中。 这意味着在该函数内发生的交换“有效”直到swap返回。 实际上，主体中的m，n仍保留其原始值。<br>但是，函数参数可以是任何类型（即，不仅是上述int之类的原始类型）。<br>在C语言中，非常有用的类型是指向其他类型的指针。 例如，我们可以定义以下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* px = &amp;x;</span><br></pre></td></tr></table></figure>
<p>第一个声明整数变量x的声明，而第二个声明 声明int *类型的变量px，即“指向整数的指针”。 此外，指针px通过引用运算符（＆）分配给整数变量x的地址。<br>要摆脱某种类型的变量和该类型的指针变量之间的区别，请参考下图：<br><img src="/2021/05/02/Value-Reference-Pass/pointer.png" alt="pointer"><br>现在，当将指针传递给函数时，您仍然按值传递它。 实际上，指针变量的值已复制到函数中。 在上面的示例中，这意味着将px的副本（即x地址（例如5678）的副本）传递给该函数。<br>事实证明，在函数内部修改该指针不会更改函数外部的指针（即，指针外部仍将包含x的地址）。 但是，如果您从函数内部修改了指针所指向的对象（即x），则对象本身也会在函数外部得到修改。 但为什么？</p>
<p>由于具有相同值的两个指针（即原始指针和复制的指针）始终指向相同的对象（即它们包含相同的地址），因此可以通过这两个对象访问和修改所指向的对象。 尽管实际上没有引用存在，但这给出了通过引用传递指向对象（即x）的语义：简单地说，相对于C ++，C中没有引用。<br>让我们看一下我们的swap函数，该函数现在将两个指向整数的指针作为输入，而不是直接将两个整数作为输入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *x; <span class="comment">// the * operator is used to &quot;de-reference&quot; the pointer </span></span><br><span class="line">                  <span class="comment">// i.e., to get the actual object which the pointer points to</span></span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before swapping (m,n) evaluate to: (%d,%d)\n&quot;</span>,m,n);</span><br><span class="line">    swap(&amp;m,&amp;n); <span class="comment">// now swap takes two integer pointers as arguments</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After swapping (m,n) evaluate to: (%d,%d)\n&quot;</span>,m,n); <span class="comment">// m and n now have swapped their original values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，当将一个或多个指针传递给一个函数（即int * x，int * y）时，我们可能会指出它们所指向的相应对象（即分别为int x，int y）已“通过引用传递” 但实际上，这些物体实际上从未真正传递过任何地方。 这只是将其指针复制到函数中而产生的副作用，并且给我们口头含义是“按值传递”和“按引用传递”。<br> 该术语的用法由标准中的术语支持。 当您具有指针类型时，它所指向的类型称为其引用类型。 即，int <em>的引用类型为int。<br>另外，虽然一元运算符</em>（如* x和* y）在标准中被称为间接寻址，但通常也被称为对指针的解引用。 这进一步（误导）促进了C语言中“通过引用传递”的概念。</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><p>C++采纳了C语言的许多原始语言功能。其中包括指针，因此这种“按引用传递”的通俗形式仍然可以使用，即上面定义的交换函数，该函数接受指针并通过取消引用运算符交换其值（  *）仍然有效。<br>但是，将此术语与C ++一起使用可能会造成混淆，因为C ++引入了C所不具备的功能：能够真正传递引用。<br> 后跟与符号（＆）的类型是参考类型。 例如，int＆是对int的引用。 当将参数传递给采用引用类型的函数时，该对象实际上是通过引用传递的。 没有指针，也没有对象的复制。 绑定在函数主体内部的名称实际上是指与传入对象完全相同的对象。与指针的差异可能看起来很细微，但实际上是基本的。<br>如果使用引用类型而不是指针作为输入参数，则swap函数看起来如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the ampersand operator (&amp;) states that both the input arguments to this function</span></span><br><span class="line"><span class="comment">// will actually be references to the arguments used during function call  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before swapping (m,n) evaluate to: (%d,%d)\n&quot;</span>,m,n);</span><br><span class="line">    swap(m,n); <span class="comment">// we now invoke the function on the two integer types</span></span><br><span class="line">               <span class="comment">// but in fact their corresponding reference types will be passed to the swap function</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After swapping (m,n) evaluate to: (%d,%d)\n&quot;</span>,m,n); <span class="comment">// m and n now have swapped their original values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，没有按值传递任何内容，也没有复制任何内容。<br>与C语言不同，在C语言中，按引用传递是仅按值传递指针的“副作用”，而在C ++中，我们可以通过引用自然地传递。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>某种程度上，这仅是编程语言如何真正实现“按引用传递”的概念的问题：</p>
<ul>
<li>C通过使用指针并将其按值传递给函数来实现这一点</li>
<li>C ++提供了两种实现。 从一方面讲，它重用了从C派生的相同机制（即指针+按值传递）。</li>
<li>C ++还提供了本机的“按引用传递”解决方案，该解决方案利用了引用类型的思想。 因此，即使在C ++中，即使您要传递一个C指针，也并不是真正按引用传递，而是按值传递指针（当然，除非您将指针传递给引用！例如，int）。  *＆）。</li>
</ul>
<p>由于“按引用传递”一词可能存在歧义，因此最好在使用引用类型时仅在C ++上下文中使用它。<br>但是，当使用指针+“按值传递”时，您可能会遇到“按引用传递”的用法，但是现在至少您知道实际情况是什么！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/C/">C</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/02/VM-Page-Swap/"><span>虚拟内存，分页和交换</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/VM-Page-Swap/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T03:37:43.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h2><p>虚拟内存是一种使用硬件（MMU）和软件（操作系统）实现的内存管理技术。 通过引入虚拟地址空间的概念，它从系统上可用的实际内存中抽象出来，该概念允许每个进程将物理内存视为连续的地址空间（或连续的段的集合）。<br>虚拟内存的目标是将执行程序生成的虚拟内存地址映射到计算机内存中的物理地址。 这涉及两个主要方面：地址转换（从虚拟到物理）和虚拟地址空间管理。</p>
<ul>
<li>地址转换:前者通过称为内存管理单元或MMU的特定硬件元素在CPU芯片上实现。</li>
<li>虚拟地址空间管理:由操作系统提供，设置虚拟地址空间（即，用于所有进程的单个虚拟空间或用于每个进程的一个虚拟空间），并实际将实际内存分配给虚拟内存。</li>
</ul>
<blockquote>
<p>此外，操作系统内的软件可以提供虚拟地址空间，该虚拟地址空间可以超过主存储器的实际容量（即，也使用辅助存储器），因此可以引用比系统中物理上存在的更多的存储器。</p>
</blockquote>
<p> 虚拟内存的主要好处包括：使应用程序（和程序员）不必管理共享的内存空间；由于内存隔离而提高了安全性；以及使用分页技术，在概念上可以使用比物理上可用的更多的内存。 实际上，几乎每种虚拟内存实现都将虚拟地址空间划分为连续的虚拟内存地址块，称为页面，通常大小为4 KB。<br>为了将进程的虚拟地址转换为硬件用来实际处理指令的物理内存地址，MMU使用了所谓的页表，即由OS管理的数据结构，用于存储虚拟地址和物理地址之间的映射 。<br>具体而言，MMU存储了整个OS页表中存储的映射中最近使用的映射的缓存，这称为转换后备缓冲区（TLB）。<br>下图描述了如上所述的地址转换任务。<br><img src="/2021/05/02/VM-Page-Swap/mmu.jpeg" alt="mmu"><br>当虚拟地址需要转换为物理地址时，MMU首先在TLB缓存中搜索它（上图中的步骤1.）。 如果找到匹配项（即TLB命中），则返回物理地址，然后继续进行计算（2.a.）。 相反，如果在TLB高速缓存中虚拟地址不匹配（即TLB未命中），则MMU在整个页表中搜索匹配，即页面遍历（2.b.）。 如果页表上存在此匹配项，则将其相应地写入TLB缓存（3.a.）。 因此，地址转换将重新启动，以便MMU能够在更新的TLB（1＆2.a.）上找到匹配项。<br>不幸的是，页表查找可能由于两个原因而失败。 </p>
<ul>
<li>第一个是指定的虚拟地址没有有效的转换时（例如，当进程尝试访问它无法请求的内存区域时）。 </li>
<li>否则，如果此时未将请求的页面加载到主存储器中，则可能会发生这种情况（相应页面表条目上的相应标志指示这种情况）。 </li>
</ul>
<p>在这两种情况下，控件都从MMU（硬件）传递到页面管理器（操作系统内核的软件组件）。 在第一种情况下，页面管理程序通常会引发分段错误异常（3.b.）。 在第二种情况下，发生页面错误（3.c.），这意味着必须从当前存储该页面的辅助存储（即磁盘）中检索请求的页面。 因此，页面管理器访问磁盘，将与引起页面错误的虚拟地址相对应的页面重新存储在主存储器中（4.），并使用虚拟地址和物理地址之间的新映射来更新页面表和TLB。 地址已存储页面的位置（3.a.），最后告诉MMU重新开始该请求，以便发生TLB命中（1＆2.a.）。<br>事实证明，上述任务一直有效，直到主内存中有足够的空间来存储从磁盘返回的页面为止。 </p>
<blockquote>
<p>但是，当所有物理内存都用完时，页面管理器还必须释放主内存中的页面以允许存储来自磁盘的传入页面。 </p>
</blockquote>
<p>为了公平地确定要从主内存移动到磁盘的页面，页面调度管理程序可以使用几种页面替换算法，例如最近最少使用（LRU）。 一般而言，将页面从/从辅助存储器移动到/从主存储器移动页面称为交换（4.），这就是为什么可能会发生页面错误的原因。<br> 现在让我们回到在典型的32位Linux操作系统上OS内核和用户模式虚拟内存空间之间的分离，这已在<a href="https://rickli.github.io/2021/05/01/Understanding-Memory-Layout/">程序（进程）的内存中布局</a>中介绍，并在下面进行了介绍。<br> <img src="/2021/05/02/VM-Page-Swap/memory_layout.jpeg" alt="memory_layout"><br> 这并不意味着内核会使用那么多物理内存。 相反，这只是虚拟地址空间的一部分，可用于映射OS内核希望的任何物理内存，并且它与可用物理内存的大小正交。 </p>
<blockquote>
<p>还要注意，在Linux中，内核空间一直存在，并且在所有进程中都映射相同的物理内存，这意味着内核空间不会改变，并且在任何进程上下文切换中都映射到相同的物理内存地址。</p>
</blockquote>
<p> 按照上面的拆分规则，内核具有专用的1 GB内核虚拟地址空间，并且无论它进行什么分配，它始终使用那些地址集。 虚拟地址到物理内存地址的实际映射完全通过硬件（即MMU）和软件（即OS页面管理程序）的组合进行了上述流程。<br>  假设系统X拥有512 MB的物理内存，则仅将整个1 GB虚拟空间中的512 MB映射为内核地址空间，而其余512 MB虚拟地址未映射。 另一方面，如果X具有2 GB的物理内存，则整个1 GB的虚拟地址将被映射到物理地址。<br> 如果整个内核都不适合物理内存，则拥有虚拟内存可以使OS内核页面部分驻留在辅助存储（即磁盘）上。 实际上，这种情况不会发生（至少在Linux上是这样），因为最新的Linux内核大约只需要70 MB，这大大低于当今现代系统上可用的物理内存量。 此外，内核具有的数据和代码出于效率原因必须始终保存在主存储器中，并且还因为无法以其他方式处理页面错误。 想一想在发生页面错误时我们上面讨论的内容：OS内核（实际上是OS页面管理程序）控制系统，输入特定的中断服务例程（ISR）来处理页面错误，并将控制权交还给 产生页面错误的用户进程。 如果OS内核不完全适合主内存，则可能发生内核本身生成页面错误的情况。 在非常糟糕的情况下，这种页面错误可能例如使页面与页面错误处理例程的代码有关，从而阻塞了整个系统！ 因此，内核代码和数据始终是可寻址的（即，它永远不会产生页面错误），并随时可以处理中断或系统调用。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/02/Multiprogramming-Multiprocessing-Multitasking-Multithreading/"><span>多程序，多处理，多任务和多线程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/02/Multiprogramming-Multiprocessing-Multitasking-Multithreading/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-02T03:12:47.000Z">
          2021-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>当您使用操作系统概念时，可能会有一些令人困惑的术语，看起来很相似，但实际上是指不同的概念。<br>在本文中，我将尝试阐明经常引起困惑的四个此类术语：多程序设计，多处理，多任务和多线程。<br>在现代计算系统中，通常有多个并发的应用程序进程争用（很少）资源，例如CPU。 正如我们已经介绍的那样，操作系统（OS）除其他职责外，还负责有效和高效地分配这些资源。 一般来说，处理资源分配的OS模块称为调度程序。 根据要实现的OS的类型，可以实现不同的调度策略。</p>
<h2 id="多程序设计"><a href="#多程序设计" class="headerlink" title="多程序设计"></a>多程序设计</h2><p>在多程序系统中，主存储器中已加载一个或多个准备执行的程序。</p>
<p>一次只有一个程序能够使CPU执行其指令（即，系统上最多有一个进程正在运行），而其他所有程序都在等待它们的执行。</p>
<p>多程序设计的主要思想是最大限度地利用CPU时间。 假设当前正在运行的进程正在执行I / O任务（根据定义，它不需要完成CPU）。 然后，OS可能会中断该进程并将控制权交给准备执行的其他主内存程序之一（即进程上下文切换）。 这样，系统不会在等待I / O任务完成之前浪费CPU时间，并且运行的进程会一直执行，直到它自愿释放CPU或阻塞以进行I / O操作为止。 </p>
<p>因此，多程序设计的最终目标是只要有准备好执行的进程，就能使CPU保持忙碌状态。</p>
<p>请注意，为了使这样的系统正常运行，操作系统必须能够将多个程序加载到主内存的单独区域中，并提供所需的保护，以避免一个进程被另一个进程修改的机会。 </p>
<p>当程序中有多个程序进入或离开主存储器时，在内存中有多个程序时需要解决的其他问题是碎片化。</p>
<p>同样需要处理的另一个问题是大型程序可能无法一次放入内存中，这可以通过使用分页和虚拟内存来解决。 请参考<a href="https://rickli.github.io/2021/05/02/VM-Page-Swap/">这篇文章</a>，以获取更多详细信息。<br>最后，请注意，如果有N个就绪的进程，并且所有进程都受到CPU高度限制（即，它们大部分执行CPU任务，并且没有I / O操作或很少有I / O操作），那么在最坏的情况下，一个程序可能会等待所有其他程序 N-1个要在执行之前完成。</p>
<h2 id="多处理"><a href="#多处理" class="headerlink" title="多处理"></a>多处理</h2><p>多处理有时是指同时执行多个进程（程序）。 这可能会引起误解，因为我们之前已经引入了“多程序”一词来描述。</p>
<p>实际上，多处理是指硬件（即CPU单元）而不是软件（即正在运行的进程）。 如果底层硬件提供了多个处理器，那么这就是多处理。 存在基本方案的几种变型，例如，一个管芯上的多个核或一个封装中的多个管芯或一个系统中的多个封装。</p>
<p>无论如何，可以通过使多个程序同时运行来对系统进行多程序处理，也可以通过具有一个以上的物理处理器来对系统进行多处理。多核CPU可以同时执行多个进程。</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>多任务处理具有与多程序设计相同的含义，但是从更一般的意义上讲，因为它指的是同时运行多个（程序，进程，任务，线程）。 当多个任务共享一个共同的处理资源（例如，CPU和内存）时，该术语在现代操作系统中使用。 </p>
<p>在任何时候，CPU仅在其他任务等待轮流执行时才执行一个任务。当将CPU重新分配给另一个任务时（即进程或线程上下文切换），就可以实现并行性的错觉。</p>
<p>多任务和多编程之间存在细微的差异。 多任务操作系统中的任务不是整个应用程序，但是当一个进程分为子任务时，它也可以称为“执行线程”。 每个较小的任务都不会像以前的多程序一样完成CPU的劫持，而是占用相当一部分的CPU时间（称为量子）。</p>
<p>为了易于记忆，多程序和多任务操作系统都是（CPU）时间共享系统。 </p>
<p>但是，在多程序（较旧的OS）中，一个程序作为一个整体会一直运行直到阻塞为止，而在多任务（现代OS）中，时间共享是最好的体现，因为每个运行的进程仅占用相当一部分CPU时间。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>到现在为止，我们已经讨论了多程序设计，它是一种允许多个程序驻留在主内存中并且（显然）同时运行的方法。 然后，多任务处理是指通过共享CPU时间同时（显然）同时运行的多个任务。 最后，多核处理描述了具有多个CPU的系统。 那么，多线程从何而来呢？</p>
<p><strong>多线程</strong> 是一种执行模型，它允许单个进程在该进程的“上下文”内同时运行多个代码段（即线程）。 您可以将线程视为共享父流程资源但独立执行的子流程。 </p>
<p>单个进程的多个线程可以在单个CPU系统中共享CPU，或者（完全）在多处理系统中并行运行。为什么我们需要在单个进程上下文中拥有多个执行线程？</p>
<p>好吧，例如考虑一个GUI应用程序，用户可以在其中发出需要很长时间才能完成的命令（例如，复杂的数学计算）。 除非您将此命令设计为在单独的执行线程中运行，否则您将无法与主应用程序GUI进行交互（例如，更新进度条），因为在进行计算时该命令将无响应。</p>
<p>当然，设计多线程/并发应用程序需要程序员处理开发单线程顺序应用程序时根本不会发生的情况。 例如，当两个或多个线程尝试访问和修改共享资源（竞争条件）时，程序员必须确保这不会使系统处于不一致或死锁状态。 通常，此线程同步是使用OS原语（例如互斥体和sempaphores）解决的。</p>
<h3 id="有关上下文切换的附带说明"><a href="#有关上下文切换的附带说明" class="headerlink" title="有关上下文切换的附带说明"></a>有关上下文切换的附带说明</h3><p>上下文切换的概念适用于多程序设计以及多任务，但粒度不同。 在前者中，“上下文”是指整个过程的上下文，而在后者中，“上下文”可能是较轻的线程的上下文。 实际上，进程上下文切换涉及切换虚拟内存地址空间：这包括内存地址，映射，页表和内核资源。 另一方面，线程上下文切换是在同一进程中从一个线程切换到另一个线程的上下文切换（即，无需切换虚拟内存地址空间，因为“切换器”和“切换者”线程共享相同的虚拟地址空间）  ）。 这需要切换处理器状态（例如程序计数器和寄存器内容），这通常非常有效。<br>当然，跨不同进程在线程之间切换就像进程上下文切换一样。</p>
<h2 id="Program-vs-Process"><a href="#Program-vs-Process" class="headerlink" title="Program vs. Process"></a>Program vs. Process</h2><p>实际上，这是一个“微妙”的问题，因为有时会误将这两个术语用于指代相同的概念。<br>此外，这是面试官在您申请软件工程师职位时可能会提出的“经典”问题之一。<br> 简而言之，程序是一个可执行文件，驻留在辅助持久性存储器（即磁盘）上，并且仅包含完成特定工作所需的指令集。 例如，ls程序是一个可执行文件，存储在运行类Unix操作系统的系统磁盘上的/ bin / ls中。<br>相反，当被加载到主存储器时，进程是程序的特定执行实例，即，在程序内收集的那些指令的实际执行。 例如，您可能在上面的ls程序中有多个正在运行的实例，因此同一程序有多个进程。 事实证明，可以将程序视为“静态/被动”实体，而将流程视为“动态/主动”实体。<br> 通常，一个进程由以下资源组成：<br> –内存，包括可执行代码的映像，特定于进程的数据（输入和输出），调用堆栈（以跟踪活动子例程和/或其他事件）， 还有一个堆，用于保存在运行时生成的中间计算数据。<br>–分配给进程的资源的操作系统描述符，例如文件描述符（Unix术语）或句柄（Windows）。<br>–安全属性，例如流程所有者和流程的权限集。<br>–处理器状态（即上下文），例如寄存器的内容，物理存储器的寻址等。状态通常在进程执行时存储在计算机寄存器中，否则存储在主存储器中。<br>操作系统将有关活动进程的大多数此类信息保存在称为“进程控制块（PCB）”的数据结构中。</p>
<h2 id="时间共享"><a href="#时间共享" class="headerlink" title="时间共享"></a>时间共享</h2><p>回想一下，在单处理器系统中，并行执行是一种错觉。 即使多个进程驻留在主存储器中，CPU也可以一次执行一个进程的一条指令。 想象一下一家餐厅，只有一个服务员，很少有顾客。 服务员无法一次为一个以上的客户提供服务，但是如果碰巧服务生足够快地在桌子上旋转并快速提供食物，那么您会感觉到所有客户都在同一时间被服务 。 这是在进程（客户）之间共享CPU时间（或侍者时间）时共享时间的示例。 多程序设计和多任务操作系统不过是分时系统。 在多程序设计中，尽管在程序之间共享CPU，但它不是CPU时间共享的完美示例，因为一个程序一直运行直到被阻塞为止，但是在多任务处理（现代操作系统）中，时间共享最好地体现出来，因为每个运行进程只占用一个公平的时间。  CPU时间量称为量子时间。 即使在多处理系统中，当我们有多个处理器时，每个处理器时间仍在运行的进程之间共享。 如您所见，所有术语都以某种方式相互关联，但是没有在正确的上下文中使用正确的术语是造成混淆的原因，因此请记住这一点。</p>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>在本文开头，我们提到系统的特征在于需要实现的目标。 在典型的时间共享中，调度操作系统进程，以便在组之间共享CPU时间。 根据调度算法，每个进程都会获得其CPU时间的共享量，但不能保证每个进程都会在需要时获得CPU。 另一方面，在实时系统中，当特定事件发生时，可以确保进程引起CPU的注意。 从事件触发到系统响应之间应该有一个操作期限。 实时系统中的过程是至关重要的任务，例如在装配线中的工业机器人中，每个阶段都需要进行某些操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多编程，多任务，多线程，时间共享和实时系统均指的是用于CPU执行的调度过程的软件实现。 每个调度实现都实现某些设计目标，这些目标表征了特定的操作系统类型。 另一方面，多处理是指基础硬件提供的CPU单元数。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/OS/">OS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/Library-Difference/"><span>静态库、动态库、Swift Package？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/Library-Difference/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T06:43:18.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>每个开发人员都知道在项目中支持干净架构的重要性。 偏好模块化代码库以独占应用程序的原因显而易见。 它们是命名空间，访问控制，在不同的模块中使用不同的编程语言。 当然，还有代码重用。</p>
<p>在本文中，我们将讨论基于iOS Swift的项目中支持模块化代码库的选项，其中包括：</p>
<ul>
<li>librarys; </li>
<li>框架，包括新的XCFramework bundle类型；<br>Swift软件包。<br>尽管仅限于iOS，但这并不意味着您不能在其他Apple平台上使用这些方法。<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3>Swift中基于<a target="_blank" rel="noopener" href="https://swift.org/package-manager/">模块</a>的代码组织和访问控制的概念。 该模块表示为单个代码分发单元。 在Xcode中将框架，库，快速包和构建目标视为单独的模块。 每个都有其命名空间和访问控制。 通常，模块可以解决特定问题。 它可以在不同情况下重用。</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/bundle">Bundle</a></strong> 是一个文件目录，其中包含子目录。 在iOS上，bundle包用于将相关文件方便地一起打包到一个包中，例如图像，nibs或编译后的代码。 系统将其视为一个文件，您可以在不知道其内部结构的情况下访问Bundle资源。 无法链接的Dylib，只能在运行时使用<code>dlopen()</code>打开</p>
<p><strong>源文件</strong> 是模块中的单个Swift源代码文件。<br><strong>可执行文件</strong> 应用程序的主要二进制文件。<br><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_file#targetText=An%20object%20file%20is%20a,work%20like%20a%20shared%20library.">目标文件</a></strong> 目标文件是包含<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_code">目标代码</a>的文件，这意味着通常无法直接执行的可重定位格式的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Machine_code">机器代码</a>。 目标文件也可以像<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_library">共享库</a>一样工作。<br><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_code">目标代码</a></strong> 在计算中，目标代码或目标模块是编译器的产物。 在一般意义上，目标代码是计算机语言，通常是机器代码语言（即，二进制或中间语言，例如寄存器传送语言）中的一系列语句或指令。</p>
<h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>在计算机科学中，库意味着将资源和代码收集到一个或多个体系结构中。 使用iOS应用程序时，您将面临静态和动态库。 让我们来看看它们是什么。<br><strong><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html">静态库</a></strong> (*.a) （<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">静态归档库</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">静态链接</a>的共享库）—目标文件的集合或归档。 静态链接器将带有库代码的应用程序编译的源代码收集到单个可执行文件中，该文件在运行时全部加载到内存中。<br><img src="/2021/05/01/Library-Difference/link_static_library_memory_usage.png" alt="Linking static library and memory usage"><br>由于静态库在一般意义上是机器代码语言中的一系列语句或指令，因此添加了一些限制来创建和分发它们：您需要为与客户端代码相同的处理器体系结构构建一个库。  。 例如，如果您正在为iOS应用程序使用库，则需要为iOS Simulator和iOS设备创建一个库。</p>
<p>该库不能包含资源文件：图像，assets，nibs，字符串文件和其他可视数据。 如果要包括工程的这些资源，则这些资源将与.a文件分开。 通常，作为解决此问题的方法，所有方法都与另一个独立bundle包中提供的外部资源有关。</p>
<p>您可以创建一个Swift静态库，这是Xcode 9.0支持的。 Xcode 9支持了动态框架。 使用CocoaPods的开发人员请记住，添加use_frameworks是必需的。 它告诉CocoaPods您想使用Frameworks而不是Static Libraries，因为Swift不支持它。 但是幸运的是，Swift和Xcode一直在不断改进，现在我们已经支持Swift静态库。</p>
<p>静态库的格式在Windows下为.lib，在Linux或Mac下为.a。 整个静态库将被加载到目标文件中，并在编译期间保持静止。 静态库的好处是目标程序可以不受任何外部依赖地运行，即，您可以根据需要将此程序复制到其他系统。 但是缺点是它将使程序变大。</p>
<p><strong>动态库</strong>  (*.dylib)（<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">动态共享库</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">共享对象</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1">动态链接库</a>）不会像静态库一样复制到可执行文件中。 相反，当二进制文件和库都在内存中时，它们会在加载或运行时动态链接。 动态库分别存储和版本控制。 结果，如果更新被认为与原始版本二进制兼容，则动态库可能加载的内容与原始引用的内容不同。<br><img src="/2021/05/01/Library-Difference/link_dyld_memory_usage.png" alt="link_dyld_memory_usage"><br>系统iOS和macOS库是动态的。 这意味着您的应用将获得Apple更新的改进，而无需提交新的版本。 这也可能导致互操作性问题。 因此，在新版OS发行前测试该应用程序始终是个好主意。<br>关于iOS应用程序自己的自定义.dylib的创建和集成，有一些旧的讨论：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48209855/xcode-9-no-option-to-create-dylib-project-ios">topic1</a>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4733847/can-you-build-dynamic-libraries-for-ios-and-load-them-at-runtime">topic2</a>。 尽管如此，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/technotes/tn2435/_index.html#//apple_ref/doc/uid/DTS40017543-CH1-PROJ_CONFIG-APPS_WITH_DEPENDENCIES_BETWEEN_FRAMEWORKS">Apple文件</a>清楚地指出：</p>
<blockquote>
<p>除了Xcode提供的系统Swift库外，iOS，watchOS或tvOS上不支持框架捆绑包之外的动态库（通常具有文件扩展名.dylib）。</p>
</blockquote>
<p>动态库（Windows下为.dll，Linux下为.so，而Mac下为.dylib / .tbd）将不会加载到目标程序中。目标程序仅在编译短语期间加载引用。 动态库将在运行时加载。<br>无需重新编译整个程序即可轻松升级Dynamic库</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><blockquote>
<p>框架（.framework）：是一个分层目录，它将动态库，头文件和资源（例如storyboards，图像文件和本地化的字符串）封装到一个包中。 使用框架的应用程序需要将框架嵌入到应用程序包中。<br>旨在与静态和动态共享库相同的目的的框架。 但是与库不同，框架：</p>
</blockquote>
<ul>
<li>可以包含图像，assets，文档，字符串文件之类的资源。</li>
<li>仅将一个框架只读资源的副本加载到内存中，从而可以减少内存占用并在iOS应用程序和扩展之间共享框架。<br>关于框架和库之间的区别还有另一种观点，这是基于架构师和简洁设计的观点。 <a target="_blank" rel="noopener" href="https://martinfowler.com/">马丁·福勒（Martin Fowler）</a>在精彩的文章“<a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/InversionOfControl.html">控制反转</a>”中说，控制反转是使框架与库不同的关键部分：</li>
<li>该库本质上是可以调用的一组函数，这些天通常组织成类。 每个调用都会执行一些工作，并将控制权返回给客户端。</li>
<li>框架体现了一些抽象设计，并内置了更多的行为。要使用它，您需要通过子类化或插入自己的类将行为插入框架中的不同位置。 然后，框架的代码将在这些位置调用您的代码。 程序的主控件被反转，从您移至框架。<br>在iOS 8之前，Apple不允许使用Dynamic Framework。 引入动态框架可能是因为Apple开始支持扩展的原因。 使用扩展程序，必须拥有与相应应用程序中使用的相同的框架。<br>iOS 8才开始支持的Dynamic 框架。</li>
</ul>
<p>在iOS中，Apple使用Framework打包头文件，源文件，二进制文件和资源。 同样，框架可以分为静态框架和动态框架。</p>
<p>关于框架的讨论也值得一提的是伞形框架和通用框架（胖框架）：伞形框架：是包含其他框架的框架包。 伞框架可用于macOS应用程序，但Apple不建议使用它们。  iOS，watchOS或tvOS不支持伞框架。</p>
<p>通用框架（fat框架）：多体系结构二进制文件，其中包含本机针对多个指令集的代码，并且可以在多种处理器类型上运行。 简而言之，它包含为您要支持的所有平台编译的代码。 例如，用于设备的x86_64（64位模拟器），arm64 arm64e armv7 armv7s。 结果，这样的框架将比一个架构的框架具有更大的规模。 有很多关于如何使用lipo制作通用框架的教程。 此方法广泛用于共享私有二进制文件。 这样，您的框架使用者就可以在真实的设备和模拟器上使用您的框架。</p>
<p>您可以在终端中使用file命令获得框架：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;PathToAppFramework&gt;/&lt;FrameworkName&gt;.framework/&lt;FrameworkName&gt;</span><br></pre></td></tr></table></figure>
<p>要将所有动态链接的框架和库检查为二进制文件，可以使用otool：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -L &lt;PathToArchive&gt;/Products/Applications/&lt;AppName&gt;.app/&lt;AppBinary&gt;</span><br></pre></td></tr></table></figure>
<p>苹果表示，APP平均包含100-400个系统dylib。 系统框架的加载已高度优化。 但是加载自定义嵌入式框架可能会很昂贵。  Apple的工程师鼓励您明智地使用框架，并限制框架的使用量，因为这会影响应用程序的启动时间。 如果您对框架的工作原理及其对应用程序启动时间的影响感兴趣，请查看WWDC会话“<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/406/">优化应用程序启动时间</a>”。</p>
<p>苹果公司宣布Swift 5为应用程序提供二进制兼容性，这意味着使用一个版本的Swift编译器构建的应用程序将能够与使用另一个版本的库进行通信。 目前，Swift的ABI已宣布在Apple平台上对Swift 5稳定。</p>
<h3 id="XCFrameworks"><a href="#XCFrameworks" class="headerlink" title="XCFrameworks"></a>XCFrameworks</h3><p>XCFrameworks是一种新的受支持的分发二进制框架的方法，可从Xcode 11获得。实际上，该框架现在可以包含用于多个体系结构和平台的代码。 您仍然需要为不同的平台生成存档，并将它们捆绑在一起在单个XCFrameworks中。  WWDC 2019有一个很棒的会议：<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/416/">Swift中的二进制框架</a>，详细解释了如何创建，集成和分发XCFrameworks</p>
<p>使用XCFrameworks的优点很少：</p>
<ul>
<li>XCFramework不仅包含针对设备和模拟器的变体，而且还包含针对Xcode支持的任何平台的变体：iOS，macOS，tvOS，watchOS； </li>
<li>它支持Swift和基于C的代码； </li>
<li>可以打包框架和静态库。<br>借助Xcode 12中的新软件包清单API，现在可以制作包含一个或多个XCFrameworks的Swift软件包。 您可以在官方文档以<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift_packages/distributing_binary_frameworks_as_swift_packages">Swift软件包分发二进制框架</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10147/">WWDC 2020视频</a>中找到实现的详细信息。</li>
</ul>
<h3 id="Swift-Package"><a href="#Swift-Package" class="headerlink" title="Swift Package"></a>Swift Package</h3><p>Swift是一种跨平台语言，需要用于构建Swift代码的跨平台工具。  <a target="_blank" rel="noopener" href="https://swift.org/package-manager/#targetText=The%20Swift%20Package%20Manager%20is,in%20Swift%203.0%20and%20above.">Swift软件包管理器</a>（SwiftPM）的目标之一是简化Swift生态系统中的分发源代码。  SwiftPM是一个开源项目，您也可以在<a target="_blank" rel="noopener" href="https://github.com/apple/swift-package-manager">GitHub</a>上找到有关它的信息。<br>Swift Package包含源文件和清单文件（Package.swift）。 清单描述了Swift软件包的配置。  Swift Package是由<a target="_blank" rel="noopener" href="https://swift.org/package-manager/">Swift Package Manager</a>定义和使用的，其中包括<a target="_blank" rel="noopener" href="https://swift.org/package-manager/">Swift 3.0及更高版本</a>。 由于以源代码形式分发，因此不再需要维护客户端的二进制兼容性。 因此，如果您可以交付源代码，那么Swift Package是您的理想工具。 借助Xcode 11中的新更改，您可以轻松创建和分发Swift软件包。</p>
<p>Swift软件包包括3个部分：依赖项，目标和产品：</p>
<p>__依赖关系__：您在包内部使用的其他swift包。 在软件包文件中，每个依赖项都由源位置和版本指定。</p>
<p>__目标__：如Apple的文档所述，<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/creating_a_swift_package_with_xcode">目标是包的基本组成部分</a>。既可以是库，也可以是可执行文件。 在Xcode 12 Swift软件包之前，只能包含Swift，Objective-C / C ++或C / C ++文件。  Xcode 12提供了新的tools-version：5.3，它带来了新的包清单API。 现在，Swift包可以包含其他资源类型：图像，storyboards，JSON文件，Shell脚本等等。 您还可以本地化这些资源。 这是很棒的，希望得到改进。 感谢所有为提供此功能做出贡献的人。 有用的详细信息和实现详细信息，可以在WWDC 2020视频Swift包中找到：<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10169/">资源和本地化</a>，以及在文档<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift_packages/localizing_package_resources">Localizing Package Resources</a>中。</p>
<p>__产品__：软件包的输出，可以是软件包产生的库或可执行文件，并使它们对其他软件包可见。</p>
<p>下面是Swift软件包的优缺点:<br>优点：</p>
<ul>
<li>1.由Xcode管理的依赖关系； </li>
<li>2.由Xcode管理的版本； </li>
<li>3.无需二进制兼容性，可以在同一构建操作中针对多个平台编译软件包。 不再需要为每个平台创建单独的框架目标。 </li>
<li>4.源代码形式的分发允许检查代码并在调试时介入其中。</li>
<li>5.查看Xcode 12 Swift软件包可以包含图像，storyboards，XCFrameworks和更多其他文件类型。</li>
</ul>
<p>缺点：</p>
<ul>
<li>1.（仅在Xcode 12之前）Swift软件包包含源代码，但不支持资产和资源。</li>
<li>2.（仅在Xcode 12之前）Swift程序包只能依赖于其他Swift程序包，不支持二进制依赖性。</li>
<li>3.源代码形式的分发不适用于不想共享源代码的框架提供程序。</li>
</ul>
<p>显然，在为iOS应用程序选择静态库，框架或Swift包之间的体系结构时，应考虑每个特定项目的局限性。</p>
<p>将太多的静态库链接到应用程序中会产生较大的应用程序可执行文件，启动时间较慢，并且内存占用量很大。 与静态库相比，框架可以为您提供更多的灵活性，它们可以包含资源。 但是，添加到项目中的每个嵌入式框架也会增加启动时间。<br>如果您可以发送源文件，则Swift软件包可能是您的正确选择。  Xcode将处理所有依赖项，版本控制和平台。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>库是一个已编译的库文件，通常为二进制格式。 其他用户可以直接将其与一个或多个头文件一起使用。<br>库有两种类型：</p>
<ul>
<li>1.静态库</li>
<li>静态链接。 相关代码和地址将立即加载到主程序中。</li>
<li>它将使程序大小变大。</li>
<li>2.动态库</li>
<li>动态链接。 相关代码和地址将被计算，然后加载到主程序中。 此计算将有额外的时间。</li>
<li>与静态库相比，动态库可以由一个副本用于多个程序。不会使程序大小变大。无需重新编译整个程序即可轻松升级Dynamic库</li>
<li>缺点1:动态库/库上的额外编译时间</li>
<li>缺点2:当您尝试将程序复制到其他系统但忘记了动态库时，很容易得到诸如在Linux下的“找不到库”之类的错误</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/Understanding-Memory-Layout/"><span>Understanding Memory Layout in iOS</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/Understanding-Memory-Layout/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T06:04:27.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>内存是指存储信息以供计算机立即使用的计算机硬件集成电路。 计算机内存用于存储位模式。 不仅数据而且指令也是位模式，这些位模式可以存储在存储器中。 在系统软件中，它们存储在单独的内存段中。 这些段也按数据和程序类型进行划分。</p>
<p>多任务OS在虚拟地址空间中运行。 在64位系统的情况下，内存地址分配了8个字节，对于32位系统，分配了4个字节，对于16位系统，分配了2个字节。 此值称为地址大小，CPU可寻址的最小单位为1字节（8位）。</p>
<p>程序运行时，将在系统上称为内核空间和用户空间的两个空间中执行处理。 这两个处理空间彼此隐式地相互干扰，并且程序的处理继续进行。</p>
<ul>
<li><strong>内核空间</strong><br>用户进程只能通过使用系统调用来访问内核空间，这些系统调用是类Unix操作系统中的请求，例如输入/输出（I / O）或进程创建。</li>
<li><strong>用户空间</strong><br>用户空间是分配给用户的计算资源，并且是执行程序可以直接访问的资源。 该空间可以分为几个部分。<h3 id="程序中的内存布局"><a href="#程序中的内存布局" class="headerlink" title="程序中的内存布局"></a>程序中的内存布局</h3>下图显示了内核空间和用户空间的虚拟内存空间。 虚拟空间的用户空间部分分为栈和堆，BSS，数据，文本。<br><img src="/2021/05/01/Understanding-Memory-Layout/memory_lauout.png" alt="memory layout"><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4>栈空间位于OS内核空间的正下方，通常与堆区域相对，并向下扩展到较低的地址。  （在其他一些架构上可能会朝相反的方向发展）<br>栈是LIFO（后进先出）数据结构。 在计算机科学中，栈是一种抽象数据类型，它是元素的集合，具有两个主要操作：</li>
<li>push（将元素添加到集合中）</li>
<li>pop（弹出）将删除最近添加的尚未删除的元素。<br>该区域专用于在程序中存储函数调用所需的所有数据。 调用函数与将被调用函数的执行推入栈顶部相同，一旦该函数完成，将返回结果，将函数从堆栈中弹出。 推送给函数调用的数据集称为栈帧，其中包含以下数据。</li>
<li>传递给常规程序的参数（参数值）</li>
<li>将返回地址返回给例程的调用方，</li>
<li>程序的局部变量分配的空间<br>以下是C程序的示例和栈存储器分配的图片。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = getResult();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num1 = getNum1();</span><br><span class="line">  <span class="keyword">int</span> num2 = getNum2();</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
调用该函数时，栈帧被推到栈的顶部。 然后执行该过程，函数超出范围，栈帧从顶部弹出。<br><img src="/2021/05/01/Understanding-Memory-Layout/stack_pop_flow.png" alt="stack_pop_flow"><br>如上所述，它只能存储有限范围的数据。 但是，在内存管理中，它运行非常快，因为栈指针寄存器仅跟踪栈的顶部。<h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4>堆是通常进行动态内存分配的段。 该区域通常从BSS段的末尾开始，然后向上扩展到更高的内存地址。 在C语言中，它由malloc / new，free / delete管理，后者使用brk和sbrk系统调用来调整其大小。<br>在以下情况下，将分配到堆区域。</li>
<li>内存大小在运行时动态分配</li>
<li>范围不受限制。  （例如，从多个地方引用的变量）</li>
<li>内存大小非常大。<br>释放堆内存是我们的责任。 如果不释放堆中的对象，则会导致内存泄漏。 在垃圾回收语言中，垃圾回收器释放堆上的内存并防止内存泄漏。</li>
</ul>
<p>可以通过重复分配和释放区域来在堆上生成未使用区域。 将“未使用的节点”和“正在使用”的节点混合的状态，即未使用区域被垃圾分割成碎片的状态称为碎片状态。 在这种状态下，搜索可用空间的开销以及数据“参考位置”的性能下降，因此性能相对较低。</p>
<h4 id="BSS（Block-Started-by-Symbol）"><a href="#BSS（Block-Started-by-Symbol）" class="headerlink" title="BSS（Block Started by Symbol）"></a>BSS（Block Started by Symbol）</h4><p>未初始化的数据段，通常称为BSS段。 在程序开始执行之前，内核将此段中的数据初始化为算术0。 例如，声明为static int i的变量； 将分配给BSS段。</p>
<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>数据段包含已初始化的全局变量和静态变量，这些变量具有预定义的值并且可以修改。 它分为只读空间和读写空间。<br>例如下面的C程序main函数外</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h4><p>存储机器语言指令的段。 该段是只读空间。</p>
<h4 id="Stack-vs-Heap"><a href="#Stack-vs-Heap" class="headerlink" title="Stack vs Heap"></a>Stack vs Heap</h4><p>栈速度更快，因为所有可用内存始终是连续的。 与堆不同，没有列表需要保留所有可用内存的列表，只有一个指针指向栈的当前顶部。 栈中的每个字节都倾向于被非常频繁地重用，这意味着它倾向于被映射到处理器的高速缓存中，从而使其非常快。 因此，只要您不需要使用堆，我建议您使用栈。</p>
<h4 id="系统动态库所在的内存布局呢"><a href="#系统动态库所在的内存布局呢" class="headerlink" title="系统动态库所在的内存布局呢"></a>系统动态库所在的内存布局呢</h4><p>TODO</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_segment">Data Segment</a><br><a target="_blank" rel="noopener" href="https://gabrieletolomei.wordpress.com/miscellanea/operating-systems/in-memory-layout/">In-Memory Layout of a Program (Process)</a><br><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/memory-layout-of-c-program/">Memory Layout Of C Program</a><br><a target="_blank" rel="noopener" href="https://www.usna.edu/Users/cs/aviv/classes/ic221/s16/lec/08/lec.html">Memory Alloc And Program Memory Layout</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/Mach-O-Executable/"><span>Mach-O Executable</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/Mach-O-Executable/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T04:09:36.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>我想谈谈这个神秘的词Mach-O…<br>它是什么？<br>它是如何工作的？</p>
<p>为了解决所有这些问题，我们必须亲自动手深入挖掘…</p>
<p>当我们使用Xcode构建APP时，很多事情同时发生。 其中之一是将所有源代码转换为可执行文件。 该可执行文件包含将在CPU，iOS设备上的ARM处理器或Mac上的英特尔处理器上运行的字节码。</p>
<p>该可执行文件称为Mach-O。</p>
<h2 id="Mach-O-格式"><a href="#Mach-O-格式" class="headerlink" title="Mach-O 格式"></a>Mach-O 格式</h2><p>Mach-O是字节的二进制流，被分成有意义的数据块。 这些块包含有关元数据的信息，例如字节顺序，CPU类型，块大小等。</p>
<p>Mach-O有多种类型，最典型的是您会看到这些：</p>
<ul>
<li>可执行文件 主APP二进制文件，例如Example.app/Example</li>
<li>Dylib 动态库，例如libSwiftCore.dylib<br>因此，Mach-O文件分为几个部分，看起来像这样<br><img src="/2021/05/01/Mach-O-Executable/mach_binary.png" alt="mach binary"><br>但在深入探讨分段之前，我们先来看看其他内容</li>
</ul>
<h3 id="Mach-O-Header"><a href="#Mach-O-Header" class="headerlink" title="Mach-O Header"></a>Mach-O Header</h3><p><img src="/2021/05/01/Mach-O-Executable/Mach-O_header.png" alt="Mach-O header"><br>每个Mach-O文件都以定义文件结构的头结构开头。 它还包含有关文件类型和目标体系结构（armv7，armv7s，i386等）的信息。</p>
<p>头文件结构的正下方是一堆加载命令，这些命令有助于文件的布局和链接。 另外，加载命令可以指定</p>
<ul>
<li>文件在虚拟内存中的初始布局</li>
<li>Section名称和地址</li>
<li>要加载的dylib</li>
<li>“main”函数地址</li>
<li>代码签名<br>这就是完整的标题的样子！<br><img src="/2021/05/01/Mach-O-Executable/complete_header.png" alt="Mach-O complete header"><br>如您所见，Mach-O头文件由一堆加载命令组成，这些命令定义了各节的地址，主函数以及要加载的从属二进制文件。</li>
</ul>
<p>上面提到的地址实际上与加载Mach-O的内存地址有偏差。 这样做是因为每次启动APP时，都会使用一种称为“自动空间布局随机化”的精巧技术或我们亲切地称为ASLR的启动技术来对起始内存地址进行随机化。</p>
<p>这意味着您的APP进程启动时，您不知道它将从哪个地址开始启动。<br>让我们想象一下它的含义，假设您有一个全局变量，它占用了RAM中的某些内存地址，但是由于您不知道进程从何处开始，因此您可能无法确定该全局变量的内存地址！</p>
<p>您可能已经猜到，这样做是出于安全目的，否则，如果每次启动时所有地址都相同，那么破解二进制文件将变得非常容易！</p>
<h3 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h3><p>让我们看一下Mach-O文件的各个部分</p>
<h4 id="PAGEZERO"><a href="#PAGEZERO" class="headerlink" title="__PAGEZERO"></a>__PAGEZERO</h4><p>这是可执行文件的第一部分，内部没有数据，因此不占用文件空间。 该段充满零以捕获NULL指针取消引用。 您可能已经遇到了EXC_BAD_ACCESS崩溃，这恰恰是因为代码中的某些内容试图从此处访问数据，而这是不允许的。<br>顺便说一句，此段可能是隐藏恶意代码的好地方😉</p>
<h4 id="TEXT"><a href="#TEXT" class="headerlink" title="__TEXT"></a>__TEXT</h4><p>该段包含可执行代码和只读数据。 将该段设置为只读，以允许在将段映射到内存时共享该段。 这主要与框架，bundles和共享库一起使用。</p>
<p>并且，由于__TEXT段是只读的，因此不需要将任何更改保存回磁盘。 如果内核需要释放内存，它将仅删除__TEXT页面并在需要时重新读取它们。</p>
<p>这就是iOS和OSX如此积极地缓存其动态库的原因。</p>
<h4 id="DATA"><a href="#DATA" class="headerlink" title="__DATA"></a>__DATA</h4><p>该段包含可写数据（例如，全局变量，静态变量等），并且由于可写，因此逻辑上为与该库链接的每个进程复制框架或其他共享库的__DATA段。</p>
<p>如果您有使用Swift的经验，那么您必须熟悉写时复制，这实际上意味着在引用的内容进行编辑之前，不要创建副本。 同样，当复制__DATA段时，直到某个进程对其进行修改后，该进程才真正接收到它自己的页面私有副本。</p>
<h4 id="OBJC"><a href="#OBJC" class="headerlink" title="__OBJC"></a>__OBJC</h4><p>这是一个可选段，包含由Objective-C语言运行时支持库使用的数据。</p>
<h4 id="IMPORT"><a href="#IMPORT" class="headerlink" title="__IMPORT"></a>__IMPORT</h4><p>这也是一个可选段，包含符号存记录和指向可执行文件中未定义的符号的非惰性指针。 仅针对IA-32体系结构的可执行文件生成此段。</p>
<h4 id="LINKEDIT"><a href="#LINKEDIT" class="headerlink" title="__LINKEDIT"></a>__LINKEDIT</h4><p>该段包含链接器（链接编辑器）的原始数据，例如符号和字符串表，压缩的动态链接信息，代码签名信息以及间接符号表，所有这些数据均由装入命令指定的区域占据。</p>
<p>因此，既然我们已经了解了各个部分，那么让我们尝试着眼于大局，看看它们如何融合在一起。</p>
<h3 id="全局图—-DYLD"><a href="#全局图—-DYLD" class="headerlink" title="全局图— DYLD"></a>全局图— DYLD</h3><p>直到现在我们知道</p>
<ul>
<li>1、如何生成Mach-O文件，并使用其加载命令以各种方式链接依赖项。</li>
<li>2、加载命令用于映射内存命令中的段。</li>
<li>3、文件的执行从LC_MAIN开始<br>好吧，这仅仅是信息，而该信息需要大脑进行处理。这个大脑叫做Dyld！</li>
</ul>
<p>当您通过点击APP图标启动APP时，而不是启动您的APP，内核会启动dyld！<br>我知道，对吧！ 这个家伙在这里很重要。<br>内核实际上将在某些随机地址空间加载dyld，并且内核本身将具有自己的__TEXT段，__ DATA段……好了，您就知道了。<br><img src="/2021/05/01/Mach-O-Executable/dyld_loaded_in_RAM.png" alt="dyld loaded in RAM"><br>dyld的工作主要是为我们加载和设置所有依赖的dylib。</p>
<h4 id="加载-dylibs"><a href="#加载-dylibs" class="headerlink" title="加载 dylibs"></a>加载 dylibs</h4><p>dyld在此处读取Mach-O标头，以查找有关从属dylib的信息。 然后，它在文件系统上找到该库文件并对其进行解析。</p>
<p>此过程是递归完成的，因为dylib A可以依赖dylib B，而dylib B可以依赖dylib C，因此它必须解析整个依赖关系图，最后将所有这些dylib的段映射到原始Mach-O头文件中。</p>
<p>而且，整个处理可能看起来像这样。<br><img src="/2021/05/01/Mach-O-Executable/Multiple_dylibs_loaded.png" alt="Multiple dylibs loaded"><br>现在，请记住我们讨论过ASLR，以及如何不知道将哪个地址分配给APP中的所有变量。  dyld必须使用以下技术来解决此问题。</p>
<h4 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h4><p>__LINKEDIT部分包含所有需要移动的指针的位置。  Dyld将遍历所有这些指针，并根据您APP的起始地址对其进行移位。</p>
<p>请注意，要执行此操作，我们必须读取和写入数据页，从而导致这些页变脏，并且需要在写入时进行复制。 这就是为什么Rebasing在IO中非常昂贵的原因。</p>
<h4 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h4><p>对其他dylib函数的引用是使用绑定固定的，例如NSLog，malloc等。</p>
<p>dyld加载依赖库后，需要搜索符号表并找到这些符号的实现。<br>因此，二进制文件中实际上存在一个名为<code>_NSLog</code>的字符串，该字符串尚未解析，而dyld要做的是查找符号表，并用相关库中这些函数的地址填充该表。</p>
<p>这在计算上很复杂并且很昂贵</p>
<h4 id="Objc-Runtime"><a href="#Objc-Runtime" class="headerlink" title="Objc Runtime"></a>Objc Runtime</h4><p>所有Objc类定义都需要注册，为什么？ 因为您可以从调用<code>NSClassFromString(_:)</code>方法的字符串构造Objc类。</p>
<p>因此，dyld必须先构建此表，然后才能启动APP。</p>
<p>在类别中添加方法列表-这意味着，如果您已经在UIView上创建了一个类别并添加了许多新函数，则这些新函数将被添加到UIView的方法列表中。</p>
<p>它还可以确保<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11051528/understanding-uniqueness-of-selectors-in-objective-c/11052795#11052795">选择器是唯一</a>的。</p>
<h4 id="Run-Initializers"><a href="#Run-Initializers" class="headerlink" title="Run Initializers"></a>Run Initializers</h4><ul>
<li>此时将调用Objc <code>+ load</code>方法</li>
<li>C ++静态初始化程序<br>这是以自下而上的方式发生的，因此基本上将首先初始化从属库。<br>哇！ 完成所有这些操作之后，最后，您的<code>main()</code>将执行。<br>而且，这就是难以捉摸的Mach-O文件背后的故事。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
<li>1、二进制文件使用带有__TEXT，__ DATA和__LINKEDIT段的Mach-O格式。</li>
<li>2、Dyld需要解析并加载所有动态库依赖项。</li>
<li>3、Dyld需要修复内部和外部的所有指针（变基，绑定，设置运行时）。</li>
<li>4、运行静态初始化程序和+ load方法。</li>
<li>5、然后<code>main()</code><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3></li>
<li>1、Dyld在您的APP启动之前运行。</li>
<li>2、避免使用+ load方法，它是已弃用的API，在<code>main()</code>增加APP启动时间之前调用。</li>
<li>3、对于App库，由于dyld必须完成每个dylib的所有解析，加载和修复工作，因此dylib将招致大量启动开销。 请改用静态库。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/01/iOS-APP-Launch-Explain/"><span>iOS APP 启动详解</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/01/iOS-APP-Launch-Explain/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-01T03:03:47.000Z">
          2021-05-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>等待启动是任何APP提供的第一个用户体验。 APP的启动屏幕后面可能会发生很多事情，当然，它应该可以立即使用。 精美的动画只能吸引用户，最终，他们只是想把事情做好！</p>
<p>而且，由于一个APP一天可以启动N次，因此务必要注意该指标。 从用户点击您的APP图标到在屏幕上绘制第一个视图之间经过的所有时间都有助于您感知到APP的启动时间。</p>
<p>在讨论影响启动时间的因素之前，让我们先了解一下各种启动。</p>
<h4 id="启动类型"><a href="#启动类型" class="headerlink" title="启动类型"></a>启动类型</h4><ul>
<li>1、冷启动<br>这意味着系统内核缓冲区缓存中不存在App进程。 通常是在首次启动该APP时或在重新启动设备并清除内核缓存时发生的。 这种启动花费了最长的时间，因此应考虑进行启动时间分析。</li>
<li>2、暖启动<br>这是一种启动类型，其中APP进程和数据存在于系统的内存中，然后被带到前台。 这类似于杀死该APP并重新启动。</li>
<li>3、热启动<br>当APP从后台或挂起状态进入前台时，就会发生这种启动。</li>
</ul>
<p>现在，我们知道了启动类型，我们需要讨论两种启动时间。</p>
<h4 id="main-之前的启动-时间"><a href="#main-之前的启动-时间" class="headerlink" title="main()之前的启动 时间"></a>main()之前的启动 时间</h4><p>这是内核用于加载APP（<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">Mach-O可执行文件</a>）的时间。 您可以在此处阅读有关<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">加载顺序</a>的更多信息。</p>
<blockquote>
<p>如果您是Objective-C开发人员，则可能已经看过APP的main（），但是即使您使用Swift编写代码，该方法仍然存在，但看不到它。</p>
</blockquote>
<p>直到控件到达您APP的main（）函数为止的所有时间都计入主时间之前。</p>
<p>而且，由于所有这些都是在控件到达您的APP之前发生的，因此这段时间很难控制。 好吧，不是真的，但是我们将讨论这一点。</p>
<p>Dyld有一个内置的机制来衡量这一点，您所要做的就是编辑您的APP方案，并将环境变量DYLD_PRINT_STATISTICS添加为1，如下所示<br><img src="/2021/05/01/iOS-APP-Launch-Explain/DYLD_PRINT_STATISTICS.png" alt="scheme editor"><br>您还可以将构建配置设置为“发布”模式，最好在iPhone而不是模拟器上运行它。 完成配置并运行APP后，您会在控制台中看到类似的内容。<br><img src="/2021/05/01/iOS-APP-Launch-Explain/Pre_main_launch_metrics_in_console.png" alt="Pre-main launch metrics in console
"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dylib loading time: 378.82 milliseconds (52.2%)</span><br><span class="line">    rebase/binding time: 126687488.8 seconds (397295283.8%)</span><br><span class="line">        ObjC setup time: 115.89 milliseconds (15.9%)</span><br><span class="line">       initializer time: 335.12 milliseconds (46.2%)</span><br><span class="line">       slowest intializers :</span><br><span class="line">         libSystem.B.dylib :   5.33 milliseconds (0.7%)</span><br><span class="line">libMainThreadChecker.dylib : 301.22 milliseconds (41.5%)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面我们可以知道有许多因素会影响启动时间，例如dylib加载时间，rebase/binding， ObjC 设置， 初始化时间，libSystem.B.dylib，以及libMainThreadChecker.dylib等。</p>
<p>首先，我们需要研究第二种启动时间。</p>
<h4 id="main-之后的启动时间"><a href="#main-之后的启动时间" class="headerlink" title="main()之后的启动时间"></a>main()之后的启动时间</h4><p>这是从启动APP的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application">app:willFinishLaunchingWithOptions：</a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application">app:didFinishLaunchingWithOptions</a>到您的AppDelegate一直到第一个ViewControllers绘图周期结束为止的时间，即直到调用viewDidLoad和viewDidLayoutSubviews为止。</p>
<p>您可能已经猜到了，要测量该时间，您必须测量从willFinishLaunching方法到第一个ViewController的viewDidLayoutSubviews（通常是APP的预排/主屏幕）之间的时间。</p>
<p>并且，我们还将讨论影响启动时间的因素。</p>
<p>因此，总启动时间的最终方程为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-main() 时间 + post-main() 时间 = App 总的启动时间</span><br></pre></td></tr></table></figure>
<h4 id="影响启动时间性能的因素"><a href="#影响启动时间性能的因素" class="headerlink" title="影响启动时间性能的因素"></a>影响启动时间性能的因素</h4><p>有几个因素会影响您的启动时间效果</p>
<h5 id="动态库加载时间"><a href="#动态库加载时间" class="headerlink" title="动态库加载时间"></a>动态库加载时间</h5><p>动态加载程序（dyld）加载APP的可执行文件，并检查可执行文件中的加载命令，以查找App所需的框架和动态库。 添加到您的APP的任何动态框架都有助于这一时期。</p>
<p>因此，限制在Xcode的“Linked Frameworks and Libraries”设置嵌入的框架数量可以帮助减少启动时间。</p>
<p>您可以在此处阅读有关<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">dyld</a>的更多信息。</p>
<p>解决此问题的另一种方法是使用静态框架，它们是在编译时内置于APP可执行文件中的，因此dylib不必完成上述所有工作。<br><img src="/2021/05/01/iOS-APP-Launch-Explain/swift_framework.png" alt="swift_framework"><br>通过这样做，您可以节省大量的pre-main（）启动时间。<br><img src="/2021/05/01/iOS-APP-Launch-Explain/static_library.png" alt="static_library"><br>尽管在iOS 13中，dyld3包含在iOSAPP中，这是一个很大的改进，因为它将使iOSAPP的启动速度提高2倍。 但是，仍然无法使用静态框架。</p>
<h5 id="Static-初始化"><a href="#Static-初始化" class="headerlink" title="Static 初始化"></a>Static 初始化</h5><p>APP中的某些代码必须在iOS运行您的APP的main（）函数之前运行，这会增加启动时间。 此代码包括</p>
<ul>
<li>C / C ++静态初始化程序-通常，您不会在APP中找到类似的东西，但是如果您愿意，我希望对它有所了解。 任何定义为__attribute__((constructor)) 的函数都是C中的静态构造函数，它们的特长是在执行main（）之前调用它们！ 你可以在<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/__attribute__constructor-__attribute__destructor-syntaxes-c/">这里</a>读更多关于它的内容。</li>
<li>在OC类或Category中声明的 <code>+load</code>方法。 如上图所示，它们在<code>main()</code>之前调用，并增加了ObjC的设置时间。 此外，不建议使用此方法，而应改用<code>+ initialize</code>方法。</li>
<li>链接到APP可执行文件或Mach-O的<code>__DATA,__mod_init_func</code>段的任何函数。 这些函数通常位于__DATA段的__mod_init_func段内。</li>
</ul>
<p>因此，根据一般经验，将代码移至APP生命周期的后期，即APP启动完成后但需要工作结果之前。</p>
<p>您可以在Xcode中使用静态初始化程序工具来查找您的APP花了多少时间来运行静态初始化程序。</p>
<h4 id="UIKit生命周期方法"><a href="#UIKit生命周期方法" class="headerlink" title="UIKit生命周期方法"></a>UIKit生命周期方法</h4><p>UIKit初始化您的APP委托类的实例，并向其发送<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application"><code>application（_：willFinishLaunchingWithOptions :)</code></a>和<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application"><code>application（_：didFinishLaunchingWithOptions :)</code></a>消息。</p>
<p>这些方法在主线程上被调用，由于执行它们所花费的时间计入启动时间，因此建议仅在此处创建APP的初始显示并推迟其他任务。</p>
<p>如果有必要向用户显示之前数据，请推迟数据模型同步或API调用，直到APP运行为止。 在首次使用而不是在APP启动时初始化非视图功能，例如持久性存储和位置服务。</p>
<h4 id="初始视图层次结构"><a href="#初始视图层次结构" class="headerlink" title="初始视图层次结构"></a>初始视图层次结构</h4><p>在APP的第一帧上绘制视图所需的时间也计入启动时间。 在UIKit中，每个视图都添加到主线程上的视图层次结构中，因此，更复杂的视图层次结构会导致启动时间增加。</p>
<p>降低视图层次结构的复杂性，并用常规UIView替换覆盖<code>draw</code>方法的视图将有助于缩短加载时间。</p>
<p>尝试仅渲染屏幕上可见的视图部分。</p>
<p>可能还有很多其他原因可能会影响启动时间，但是我可以找到这些主要原因，并且，我相信，如果您认真地遵循上述方法，将会为用户创造更好的体验。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>1、有三种类型的启动类型， 冷启动，暖启动和热启动。</li>
<li>2、启动时间分为两类：<br>main之前—<code> main()</code>执行之前花费的时间<br>main之后—在<code>main()</code>执行之后直到第一个ViewController可见所花费的时间。</li>
<li>3、我们研究了导致启动时间增加的几个因素：动态库加载时间，静态初始化程序，执行AppDelegate生命周期方法所花费的时间以及绘制第一个ViewController所花费的时间。</li>
<li>4、我们发现您应该<a href="http://rickli.github.io/2021/05/01/Mach-O-Executable/">阅读本文</a>，以了解有关<code>pre-main()</code>流程的更多信息。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/406/">App Startup Time</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2019/423/">Optimizing App Launch</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/improving_your_app_s_performance/reducing_your_app_s_launch_time">Reduce App Launch Time</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/04/30/记录使用hexo-发布出错/"><span>记录使用hexo 发布出错</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/04/30/记录使用hexo-发布出错/" rel="bookmark">
        <time class="entry-date published" datetime="2021-04-30T14:07:41.000Z">
          2021-04-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>使用hexo d来推文章到github上，一直报错，尝试了很多次切换https链接发布和ssh发布都不行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Permission to someone.github.io.git denied to deploy key</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (/Users/rick/Documents/Blog/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:209:13)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure>
<p>方向错了，因为deploy失败所以潜意识一直认为是ssh的问题，执行了ssh添加id_rsa</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_swift_rsa</span><br></pre></td></tr></table></figure>
<p>最后查询到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> $(ssh-agent)</span><br><span class="line">ssh-add -K ~/.ssh/id_swift_rsa</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>通过终端执行上面的指令后，终于发布成功了。</p>
<h3 id="使用本地图显示异常"><a href="#使用本地图显示异常" class="headerlink" title="使用本地图显示异常"></a>使用本地图显示异常</h3><p>通过install hexo-asset-image这个库来显示本地图，但是发现还是无法展示，需要更改_config.yml</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://rickli.github.io/</span><br><span class="line">root: /</span><br><span class="line"></span><br><span class="line">post_asset_folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>在md需要插入图片的地方使用</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">event_respond_type</span>](<span class="link">iOS-Respond-Chain-Explain/event_respond_type.png</span>)</span><br></pre></td></tr></table></figure>
<p>Done！</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/杂记/">杂记</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/04/27/iOS-Respond-Chain-Explain/"><span>iOS 响应链详解</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/04/27/iOS-Respond-Chain-Explain/" rel="bookmark">
        <time class="entry-date published" datetime="2021-04-27T03:10:27.000Z">
          2021-04-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="iOS-响应链机制"><a href="#iOS-响应链机制" class="headerlink" title="iOS 响应链机制"></a>iOS 响应链机制</h3><p>这篇文章是为了彻底搞清楚iOS响应链而写的。<br>在iOS事件中分三部分：</p>
<ul>
<li><p>触摸事件</p>
</li>
<li><p>远程控制事件</p>
</li>
<li><p>加速计事件<br><img src="/2021/04/27/iOS-Respond-Chain-Explain/event_respond_type.png" alt="event_respond_type"></p>
<blockquote>
<p>三种事件<br>我们暂时先只关注触摸事件。</p>
</blockquote>
<h4 id="响应链对象"><a href="#响应链对象" class="headerlink" title="响应链对象"></a>响应链对象</h4><p>学习触摸事件首先要了解一个比较重要的概念-响应者对象（UIResponder）<br>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。以下都是继承自UIResponder的，所以都能接收并处理事件。</p>
</li>
<li><p>UIApplication</p>
</li>
<li><p>UIViewController</p>
</li>
<li><p>UIView<br>那么为什么继承自UIResponder的类就能够接收并处理事件呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure></li>
</ul>
<p>因为UIResponder中提供了以下4个对象方法来处理触摸事件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UIResponder内部提供了以下方法来处理事件触摸事件</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">//加速计事件</span></span><br><span class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"><span class="comment">//远程控制事件</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
<h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件</span></span><br><span class="line"><span class="comment">// 一根或者多根手指开始触摸view，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 一根或者多根手指离开view，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line"><span class="comment">// 提示：touches中存放的都是UITouch对象</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是：以上四个方法是由系统自动调用的，所以可以通过重写该方法来处理一些事件。</p>
<ul>
<li><p>如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</p>
</li>
<li><p>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象<br>重写以上四个方法，如果是处理UIView的触摸事件。必须要自定义UIView子类继承自UIView。因为苹果不开源，没有把UIView的.m文件提 供给我们。我们只能通过子类继承父类，重写子类方法的方式处理UIView的触摸事件（注意：我说的是UIView触摸事件而不是说的 UIViewController的触摸事件）。<br>如果是处理UIViewController的触摸事件，那么在控制器的.m文件中直接重写那四个方法即可！</p>
<h4 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h4><p>对于触摸事件，首先要找到能够响应该事件的对象，iOS是用hit_testing来找到哪个视图被触摸了，也就是以keyWindow为起点，hit-test view为终点，逐级调用hitTest:withEvent<br><img src="/2021/04/27/iOS-Respond-Chain-Explain/response_chain.png" alt="response_chain"></p>
</li>
<li><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是FIFO，即先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。</p>
</li>
<li><p>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</p>
</li>
<li><p>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。<br>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。<br>所以点击事件的响应是，顶部的view 传到父view，一直到父类上面<br>hitTest:withEvent方法的处理流程：</p>
</li>
</ul>
<p>先调用pointInside:withEvent:判断触摸点是否在当前视图内。</p>
<p>– 如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高(top–&gt;bottom)依次调用。</p>
<p>– 如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略（表示根本不可能在该视图内）。<br>  ●如果某视图的pointInside:withEvent:返回YES，并且它的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己self。</p>
<p>  ●如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent也返回这个对象，也就是沿原路回退，最终将hit-test view传递给keyWindow进行响应。</p>
<p> <br>  ●以下视图的hitTest-withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：</p>
<ul>
<li><p>隐藏（hidden=YES）的视图；</p>
</li>
<li><p>禁止用户操作（userInteractionEnabled = NO）的视图；</p>
</li>
<li><p>alpha&lt;0.01的视图；</p>
</li>
<li><p>视图超出父视图的区域；<br>既然系统通过hitTest:withEvent:做传递链取回hit-test view，那么我们可以在其中一环修改传递回的对象，从而改变正常的事件响应链。</p>
</li>
</ul>
<p>对于一个View，hitTest为什么会调用两次？</p>
<p>因为一次是消息传递时，还有一次是响应时。分别是入栈出栈操作，父View先入栈，后出栈。</p>
<p>不管视图能不能处理事件，只要点击了视图就会产生事件，关键看该事件是由谁来处理。也就是说，如果视图不能处理事件，点击视图，还是会产生一个触摸事件，只是该事件不会由被点击的视图处理而已。</p>
<p>技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件（我下面会实现该案例），或者重写自己的hitTest:withEvent:方法return self. 但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view。</p>
<p>return nil的含义：</p>
<p>hitTest:withEvent:中return nil的意思是调用当前的hitTest:withEvent:方法的view不是合适的view，子控件也不是合适的view。如果同级的兄弟控件也没有合适的view，那么最合适的view就是父控件。</p>
<p><code>objc[self.view convertPoint:point fromView:self]</code> </p>
<p>把self.view的坐标系从self转换到自己的坐标系。然后就可以通过手动调用pointInside来判断是否在某个view内。</p>
<h4 id="重写父视图来对子视图控制响应事件是我们推荐的方式"><a href="#重写父视图来对子视图控制响应事件是我们推荐的方式" class="headerlink" title="重写父视图来对子视图控制响应事件是我们推荐的方式"></a>重写父视图来对子视图控制响应事件是我们推荐的方式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RewriteSuperView</span> : <span class="title">UIView</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *bottom;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;RewriteSuperView.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RewriteSuperView</span></span></span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;tag=====%ld&quot;</span>,<span class="keyword">self</span>.tag);</span><br><span class="line">    <span class="built_in">CGPoint</span> bottomPoint = [<span class="keyword">self</span>.bottom convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.bottom pointInside:bottomPoint withEvent:event])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这几行代码的意思是：检测点击区域是否是在bottom区域，如果是，则直接使用bottom响应点击，否则调用父类的hitTest,按正常的传递响应。</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>总结一句：事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（子控件到父控件）。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a><a href="/tags/UI/">UI</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Rick Li
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>